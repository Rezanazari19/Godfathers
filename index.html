<!DOCTYPE htmls>
<html lang="en">
<head>
    <meta charset="UTF-8">
   <meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=3.0, user-scalable=yes">
    <title>Mafia Game Moderator</title>
    <style>
        * {
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 10px;
            background: linear-gradient(135deg, #1a252f, #2c3e50, #34495e);
            background-attachment: fixed;
            color: #ecf0f1;
            min-height: 100vh;
            font-size: 14px;
            position: relative;
        }
        
        /* Subtle animated background pattern */
        body::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-image: radial-gradient(circle at 25% 25%, rgba(52, 152, 219, 0.1) 0%, transparent 50%),
                            radial-gradient(circle at 75% 75%, rgba(231, 76, 60, 0.1) 0%, transparent 50%);
            animation: float 20s ease-in-out infinite;
            pointer-events: none;
            z-index: -1;
        }
        
        @keyframes float {
            0%, 100% { transform: translateY(0px) rotate(0deg); }
            50% { transform: translateY(-20px) rotate(180deg); }
        }
        
        .container {
            max-width: 100%;
            margin: 0 auto;
            background: rgba(44, 62, 80, 0.95);
            backdrop-filter: blur(15px);
            border-radius: 20px;
            padding: 20px;
            box-shadow: 
                0 20px 60px rgba(0, 0, 0, 0.4),
                0 0 0 1px rgba(255, 255, 255, 0.1),
                inset 0 1px 0 rgba(255, 255, 255, 0.2);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .page {
            display: none;
            animation: fadeIn 0.3s ease-in-out;
        }
        
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }
        
        .page.active {
            display: block;
        }
        
        /* Progress indicator */
        .progress-indicator {
            background: linear-gradient(90deg, #3498db, #2980b9);
            color: white;
            padding: 8px 16px;
            border-radius: 20px;
            font-size: 12px;
            font-weight: bold;
            text-align: center;
            margin-bottom: 20px;
            box-shadow: 0 4px 15px rgba(52, 152, 219, 0.3);
        }
        
        h1 {
            text-align: center;
            margin-bottom: 25px;
            font-size: 2.2em;
            background: linear-gradient(135deg, #e74c3c, #c0392b);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            text-shadow: 0 0 30px rgba(231, 76, 60, 0.3);
            font-weight: bold;
            letter-spacing: -0.5px;
        }
        
        .page-subtitle {
            text-align: center;
            color: #bdc3c7;
            margin-bottom: 25px;
            font-size: 16px;
            font-style: italic;
        }
        
        h2 {
            color: #3498db;
            margin-top: 25px;
            margin-bottom: 15px;
            font-size: 1.4em;
            font-weight: 600;
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
        }
        
        h3 {
            color: #3498db;
            margin: 20px 0 15px 0;
            font-size: 1.2em;
            font-weight: 600;
        }
        
        /* Enhanced game statistics */
        .game-stats-header {
            background: linear-gradient(135deg, rgba(241, 196, 15, 0.2), rgba(243, 156, 18, 0.2));
            border: 2px solid #f1c40f;
            border-radius: 15px;
            padding: 20px;
            margin-bottom: 25px;
            font-size: 14px;
            line-height: 1.6;
            box-shadow: 
                0 8px 25px rgba(241, 196, 15, 0.2),
                inset 0 1px 0 rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
        }
        
        .player-list-header {
            background: linear-gradient(135deg, rgba(52, 152, 219, 0.2), rgba(41, 128, 185, 0.2));
            border: 2px solid #3498db;
            border-radius: 15px;
            padding: 20px;
            margin-bottom: 25px;
            box-shadow: 
                0 8px 25px rgba(52, 152, 219, 0.2),
                inset 0 1px 0 rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
        }
        
        .player-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
            gap: 15px;
            margin-top: 15px;
        }
        
        /* Grid layout for Page 2 (Player Names) */
        .player-inputs-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin: 20px 0;
        }
        
        /* Grid layout for Page 3 (Role Assignments) */
        .role-assignments-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(320px, 1fr));
            gap: 20px;
            margin: 20px 0;
        }
        
        .player-item {
            background: linear-gradient(135deg, rgba(52, 73, 94, 0.9), rgba(44, 62, 80, 0.9));
            padding: 15px;
            border-radius: 12px;
            border: 1px solid rgba(149, 165, 166, 0.3);
            font-size: 14px;
            cursor: grab;
            user-select: none;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
            position: relative;
            overflow: hidden;
        }
        
        .player-item::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.1), transparent);
            transition: left 0.5s;
        }
        
        .player-item:hover {
            transform: translateY(-3px);
            background: linear-gradient(135deg, rgba(52, 152, 219, 0.3), rgba(41, 128, 185, 0.3));
            box-shadow: 0 8px 25px rgba(52, 152, 219, 0.2);
            border-color: #3498db;
        }
        
        .player-item:hover::before {
            left: 100%;
        }
        
        .player-item.eliminated {
            background: linear-gradient(135deg, rgba(231, 76, 60, 0.4), rgba(192, 57, 43, 0.4));
            border-color: #e74c3c;
            text-decoration: line-through;
            opacity: 0.8;
            cursor: not-allowed;
            pointer-events: none;
        }
        
        .player-item.dragging {
            opacity: 0.7;
            cursor: grabbing;
            transform: rotate(3deg) scale(1.05);
            z-index: 1000;
        }
        
        .role-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
            gap: 15px;
            margin: 20px 0;
        }
        
        .role-item {
            display: flex;
            flex-direction: column;
            align-items: center;
            background: linear-gradient(135deg, rgba(52, 73, 94, 0.9), rgba(44, 62, 80, 0.9));
            border-radius: 15px;
            padding: 20px;
            border: 1px solid rgba(149, 165, 166, 0.2);
            text-align: center;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
            position: relative;
            overflow: hidden;
        }
        
        .role-item::after {
            content: '';
            position: absolute;
            top: -50%;
            left: -50%;
            width: 200%;
            height: 200%;
            background: radial-gradient(circle, rgba(52, 152, 219, 0.1) 0%, transparent 70%);
            transform: scale(0);
            transition: transform 0.3s ease;
        }
        
        .role-item:hover {
            transform: translateY(-3px);
            box-shadow: 0 12px 35px rgba(52, 152, 219, 0.2);
            border-color: #3498db;
        }
        
        .role-item:hover::after {
            transform: scale(1);
        }
        
        .role-name {
            font-weight: bold;
            margin-bottom: 15px;
            font-size: 16px;
            color: #ecf0f1;
            text-align: center;
            z-index: 1;
            position: relative;
        }
        
        .counter {
            display: flex;
            align-items: center;
            gap: 15px;
            z-index: 1;
            position: relative;
        }
        
    .counter-btn {
    width: 40px;
    height: 40px;
    border: none;
    border-radius: 50%;
    background: linear-gradient(135deg, #3498db, #2980b9);
    color: white;
    font-size: 18px;
    font-weight: bold;
    cursor: pointer;
    transition: all 0.2s ease;
    box-shadow: 0 4px 15px rgba(52, 152, 219, 0.3);
    display: flex;
    align-items: center;
    justify-content: center;
}
        
        .counter-btn:hover {
            background: linear-gradient(135deg, #2980b9, #1f618d);
            transform: scale(1.1);
        }
        
        .counter-btn:active {
            transform: scale(0.95);
        }
        
        .counter-value {
            font-size: 20px;
            font-weight: bold;
            color: #f1c40f;
            min-width: 30px;
            text-align: center;
            background: rgba(241, 196, 15, 0.1);
            padding: 8px 12px;
            border-radius: 8px;
            border: 1px solid rgba(241, 196, 15, 0.3);
        }
        
        .total-players {
            text-align: center;
            font-size: 1.6em;
            margin: 25px auto;
            padding: 20px;
            background: linear-gradient(135deg, rgba(241, 196, 15, 0.2), rgba(243, 156, 18, 0.2));
            border-radius: 15px;
            border: 2px solid #f1c40f;
            color: #f1c40f;
            max-width: 320px;
            font-weight: bold;
            box-shadow: 
                0 8px 25px rgba(241, 196, 15, 0.3),
                inset 0 1px 0 rgba(255, 255, 255, 0.1);
        }
/* Preserve emoji colors in titles */
.emoji-icon {
    display: inline-block;
    font-style: normal;
    margin-right: 10px;
    filter: none;
    -webkit-text-fill-color: initial;
    background: none;
    -webkit-background-clip: initial;
    background-clip: initial;
}

h1 .emoji-icon {
    font-size: 0.9em;
    vertical-align: middle;
}

        
        input[type="number"] {
            width: 60px;
            padding: 8px;
            border: none;
            border-radius: 8px;
            background: rgba(236, 240, 241, 0.95);
            color: #2c3e50;
            text-align: center;
            font-weight: bold;
            font-size: 16px;
            box-shadow: inset 0 2px 5px rgba(0, 0, 0, 0.1);
        }
        
        button {
            background: linear-gradient(135deg, #3498db, #2980b9);
            color: #ecf0f1;
            border: none;
            padding: 15px 25px;
            border-radius: 25px;
            cursor: pointer;
            font-size: 15px;
            font-weight: bold;
            margin: 10px 6px;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            box-shadow: 
                0 6px 20px rgba(52, 152, 219, 0.3),
                inset 0 1px 0 rgba(255, 255, 255, 0.2);
            min-height: 48px;
            position: relative;
            overflow: hidden;
        }
        
        button::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 0;
            height: 0;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 50%;
            transform: translate(-50%, -50%);
            transition: all 0.3s ease;
        }
        
        button:hover {
            transform: translateY(-2px);
            box-shadow: 
                0 12px 35px rgba(52, 152, 219, 0.4),
                inset 0 1px 0 rgba(255, 255, 255, 0.3);
            background: linear-gradient(135deg, #2980b9, #1f618d);
        }
        
        button:hover::before {
            width: 100%;
            height: 100%;
        }
        
        button:active {
            transform: translateY(0px);
        }
        
        #toggleRolesBtn {
            background: linear-gradient(135deg, #9b59b6, #8e44ad);
            box-shadow: 0 6px 20px rgba(155, 89, 182, 0.3);
        }

        #toggleRolesBtn:hover {
            background: linear-gradient(135deg, #8e44ad, #6c3483);
            box-shadow: 0 12px 35px rgba(155, 89, 182, 0.4);
        }

        #revealBtn {
            background: linear-gradient(135deg, #27ae60, #1e8449);
            box-shadow: 0 6px 20px rgba(39, 174, 96, 0.3);
        }

        #revealBtn:hover {
            background: linear-gradient(135deg, #1e8449, #186a3b);
            box-shadow: 0 12px 35px rgba(39, 174, 96, 0.4);
        }

        button:disabled, .disabled-button {
            background: linear-gradient(135deg, #7f8c8d, #6c757d) !important;
            cursor: not-allowed;
            transform: none !important;
            box-shadow: none !important;
            opacity: 0.6;
        }
        
        .player-input {
            margin-bottom: 15px;
        }
        
        .player-input label {
            display: block;
            margin-bottom: 8px;
            font-weight: bold;
            color: #bdc3c7;
            font-size: 14px;
        }

        input[type="text"] {
            width: 100%;
            padding: 15px;
            border: 1px solid rgba(149, 165, 166, 0.3);
            border-radius: 12px;
            background: linear-gradient(135deg, rgba(52, 73, 94, 0.9), rgba(44, 62, 80, 0.9));
            color: #ecf0f1;
            font-size: 15px;
            margin-bottom: 10px;
            min-height: 50px;
            transition: all 0.3s ease;
            box-shadow: inset 0 2px 5px rgba(0, 0, 0, 0.1);
        }
        
        input[type="text"]:focus {
            outline: none;
            border-color: #3498db;
            box-shadow: 
                inset 0 2px 5px rgba(0, 0, 0, 0.1),
                0 0 15px rgba(52, 152, 219, 0.3);
            background: linear-gradient(135deg, rgba(52, 152, 219, 0.1), rgba(41, 128, 185, 0.1));
        }
        
       
.player-role-item {
    display: flex;
    flex-direction: column;  /* stack content vertically */
    justify-content: space-between;
    align-items: center;     /* keep everything centered */
    background: linear-gradient(135deg, rgba(52, 73, 94, 0.9), rgba(44, 62, 80, 0.9));
    padding: 15px;
    margin-bottom: 12px;
    border-radius: 12px;
    border: 1px solid rgba(149, 165, 166, 0.2);
    transition: all 0.3s ease;
    box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
    min-height: 140px;   /* ensures every box is same size */
}

.role-reveal,
.role-revealed {
    width: 120px;      /* same width for both */
    text-align: center;
    display: inline-block;
}
        
        .role-reveal {
            background: linear-gradient(135deg, #27ae60, #1e8449);
            padding: 10px 15px;
            font-size: 14px;
            min-height: 40px;
            border-radius: 20px;
            box-shadow: 0 4px 15px rgba(39, 174, 96, 0.3);
        }
        
        .role-revealed {
            background: linear-gradient(135deg, #e74c3c, #c0392b);
            box-shadow: 0 4px 15px rgba(231, 76, 60, 0.3);
        }
        
        .hidden-role {
            font-style: italic;
            color: #95a5a6;
            padding: 10px;
            background: rgba(149, 165, 166, 0.1);
            border-radius: 8px;
        }
        
        .elimination-section {
            margin-top: 25px;
        }
        
        .player-select {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
            gap: 12px;
            margin: 20px 0;
        }
        
        .player-button {
            background: linear-gradient(135deg, #3498db, #2980b9);
            padding: 15px 12px;
            border-radius: 20px;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            color: #ecf0f1;
            border: none;
            font-size: 14px;
            min-height: 50px;
            text-align: center;
            font-weight: 600;
            box-shadow: 0 4px 15px rgba(52, 152, 219, 0.2);
        }
        
        .player-button:hover {
            background: linear-gradient(135deg, #2980b9, #1f618d);
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(52, 152, 219, 0.3);
        }
        
        .player-button.selected {
            background: linear-gradient(135deg, #e74c3c, #c0392b);
            box-shadow: 0 8px 25px rgba(231, 76, 60, 0.4);
        }
        
        .eliminated-role {
            background: linear-gradient(135deg, rgba(231, 76, 60, 0.2), rgba(192, 57, 43, 0.2));
            border: 2px solid #e74c3c;
            padding: 15px;
            margin-top: 20px;
            border-radius: 12px;
            text-align: center;
            font-size: 16px;
            font-weight: bold;
            box-shadow: 0 8px 25px rgba(231, 76, 60, 0.2);
        }
        
        .night-action-block {
            background: linear-gradient(135deg, rgba(52, 73, 94, 0.9), rgba(44, 62, 80, 0.9));
            border: 1px solid rgba(149, 165, 166, 0.3);
            border-radius: 15px;
            padding: 20px;
            margin-bottom: 25px;
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.1);
        }
        
        .night-action-title {
            font-size: 1.3em;
            font-weight: bold;
            color: #f39c12;
            margin-bottom: 15px;
        }
        
        .player-name-display {
            color: #5dade2;
            font-weight: bold;
            margin-bottom: 10px;
            font-size: 15px;
        }
        
        .eliminated-display {
            color: #ec7063;
            font-style: italic;
            margin-bottom: 10px;
        }
        
        .radio-group {
            margin: 15px 0;
        }
        
        .radio-item {
            display: flex;
            align-items: center;
            margin-bottom: 12px;
            cursor: pointer;
            padding: 12px;
            border-radius: 8px;
            transition: all 0.2s ease;
        }
        
        .radio-item:hover {
            background: rgba(52, 152, 219, 0.1);
        }
        
        .radio-item input[type="radio"] {
            margin-right: 12px;
            transform: scale(1.3);
            accent-color: #3498db;
        }
        
        .radio-item label {
            flex: 1;
            cursor: pointer;
            font-size: 15px;
        }
        
        .jailed-message {
            color: #e74c3c;
            font-weight: bold;
            text-align: center;
            padding: 12px;
            background: linear-gradient(135deg, rgba(231, 76, 60, 0.2), rgba(192, 57, 43, 0.2));
            border-radius: 10px;
            margin: 12px 0;
            border: 1px solid rgba(231, 76, 60, 0.3);
        }
        
        select {
            padding: 15px;
            border: none;
            border-radius: 12px;
            background: linear-gradient(135deg, rgba(236, 240, 241, 0.95), rgba(220, 221, 222, 0.95));
            color: #2c3e50;
            margin: 10px 0;
            width: 100%;
            font-size: 15px;
            min-height: 50px;
            cursor: pointer;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
        }
        
        .stats-display {
            background: linear-gradient(135deg, rgba(241, 196, 15, 0.2), rgba(243, 156, 18, 0.2));
            border: 2px solid #f1c40f;
            border-radius: 15px;
            padding: 20px;
            margin: 20px 0;
            text-align: center;
            font-size: 15px;
            line-height: 1.6;
            box-shadow: 0 8px 25px rgba(241, 196, 15, 0.2);
        }
        
        .elimination-summary {
            background: linear-gradient(135deg, rgba(52, 152, 219, 0.2), rgba(41, 128, 185, 0.2));
            border: 2px solid #3498db;
            border-radius: 15px;
            padding: 20px;
            margin: 20px 0;
            text-align: center;
            box-shadow: 0 8px 25px rgba(52, 152, 219, 0.2);
        }
        
        .lock-ability {
            background: linear-gradient(135deg, rgba(155, 89, 182, 0.2), rgba(142, 68, 173, 0.2));
            border: 2px solid #9b59b6;
            border-radius: 15px;
            padding: 20px;
            margin: 20px 0;
            box-shadow: 0 8px 25px rgba(155, 89, 182, 0.2);
        }
        
        .nav-buttons {
            text-align: center;
            margin-top: 10px;
            padding: 15px 0;
        }

        .nav-buttons button {
            width: 100%;
            max-width: 350px;
            margin: 12px auto;
            display: block;
            padding: 18px 30px;
            font-size: 16px;
        }

        .day1-special {
            background: linear-gradient(135deg, rgba(52, 152, 219, 0.2), rgba(41, 128, 185, 0.2));
            border: 2px solid #3498db;
            border-radius: 5px;
            padding: 10px;
            margin: 10px 0;
            box-shadow: 0 8px 25px rgba(52, 152, 219, 0.2);
        }
.day1-special h2 {
    margin-top: 5px;
    margin-bottom: 10px;
}

.day1-special .bullet-selection,
.day1-special .bullet-squares-container,
.day1-special .player-list-header {
    margin: 10px 0;
}
        .dropdown-section {
            margin: 5px 0;
        }

        .dropdown-section label {
            display: block;
            margin-bottom: 8px;
            font-weight: bold;
            color: #bdc3c7;
            font-size: 15px;
        }

        .bullet-squares-container {
            margin: 20px 0;
        }

        .bullet-squares {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            justify-content: center;
            margin: 10px 0;
        }

        .bullet-square-wrapper {
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .bullet-label-top {
            font-weight: bold;
            color: #3498db;
            margin-bottom: 12px;
            font-size: 16px;
        }

        .bullet-square {
            width: 100%;
            min-height: 100px;
            border: 3px dashed #3498db;
            border-radius: 15px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            background: linear-gradient(135deg, rgba(52, 152, 219, 0.1), rgba(41, 128, 185, 0.1));
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            position: relative;
            box-shadow: inset 0 2px 10px rgba(0, 0, 0, 0.1);
        }

        .bullet-square.drag-over {
            border-color: #e74c3c;
            background: linear-gradient(135deg, rgba(231, 76, 60, 0.2), rgba(192, 57, 43, 0.2));
            transform: scale(1.03);
            box-shadow: 0 8px 25px rgba(231, 76, 60, 0.3);
        }

        .bullet-square.has-player {
            border-color: #27ae60;
            background: linear-gradient(135deg, rgba(39, 174, 96, 0.2), rgba(30, 132, 73, 0.2));
            border-style: solid;
        }

        .bullet-square.elimination-target {
            border-color: #e74c3c;
            background: linear-gradient(135deg, rgba(231, 76, 60, 0.3), rgba(192, 57, 43, 0.3));
            border-style: solid;
            box-shadow: 0 0 25px rgba(231, 76, 60, 0.5);
            animation: pulse 2s infinite;
        }
        
        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.02); }
        }

        .bullet-square.elimination-target .bullet-label-top {
            color: #e74c3c;
        }

        .drop-zone {
            font-size: 12px;
            color: #95a5a6;
            text-align: center;
            padding: 8px;
        }

        .bullet-square .player-in-square {
            font-weight: bold;
            color: #2c3e50;
            background: linear-gradient(135deg, #ecf0f1, #d5dbdb);
            padding: 12px 15px;
            border-radius: 15px;
            font-size: 13px;
            text-align: center;
            position: absolute;
            cursor: pointer;
            max-width: 90%;
            word-wrap: break-word;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
            transition: all 0.3s ease;
        }
        
        .bullet-square .player-in-square:hover {
            transform: scale(1.05);
            background: linear-gradient(135deg, #d5dbdb, #bdc3c7);
        }

        /* Bullet Selection Buttons */
        .bullet-selection {
            margin: 20px 0;
        }

        .bullet-selection h3 {
            margin-bottom: 20px;
        }

        .bullet-buttons {
            display: flex;
            gap: 15px;
            justify-content: center;
            margin: 20px 0;
        }

        .bullet-button {
            background: linear-gradient(135deg, rgba(52, 73, 94, 0.9), rgba(44, 62, 80, 0.9));
            color: #bdc3c7;
            border: 2px solid rgba(149, 165, 166, 0.3);
            padding: 15px 30px;
            border-radius: 12px;
            cursor: pointer;
            font-size: 15px;
            font-weight: bold;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            min-width: 140px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
        }

        .bullet-button:hover {
            background: linear-gradient(135deg, rgba(52, 152, 219, 0.4), rgba(41, 128, 185, 0.4));
            border-color: #3498db;
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(52, 152, 219, 0.2);
        }

        .bullet-button.selected {
            background: linear-gradient(135deg, #3498db, #2980b9);
            color: #ecf0f1;
            border-color: #2980b9;
            box-shadow: 0 8px 25px rgba(52, 152, 219, 0.4);
        }

        /* Night Action Tabs */
        .night-tabs {
            display: flex;
            flex-wrap: wrap;
            border-bottom: 3px solid #3498db;
            margin-bottom: 25px;
            background: rgba(52, 73, 94, 0.3);
            border-radius: 15px 15px 0 0;
            padding: 5px;
        }
        
        .night-tab {
            background: linear-gradient(135deg, rgba(52, 73, 94, 0.8), rgba(44, 62, 80, 0.8));
            border: none;
            padding: 15px 20px;
            margin: 0 3px;
            color: #bdc3c7;
            cursor: pointer;
            border-top-left-radius: 12px;
            border-top-right-radius: 12px;
            font-size: 14px;
            font-weight: 600;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
            position: relative;
            overflow: hidden;
        }
        
        .night-tab::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.1), transparent);
            transition: left 0.5s;
        }
        
        .night-tab.eliminated {
            background: linear-gradient(135deg, rgba(231, 76, 60, 0.6), rgba(192, 57, 43, 0.6));
            color: #e74c3c;
            text-decoration: line-through;
            opacity: 0.8;
        }
        
        .night-tab.eliminated.active {
            background: linear-gradient(135deg, #e74c3c, #c0392b);
            color: #ecf0f1;
            text-decoration: line-through;
            box-shadow: 0 8px 25px rgba(231, 76, 60, 0.4);
        }
        
        .night-tab.active {
            background: linear-gradient(135deg, #3498db, #2980b9);
            color: #ecf0f1;
            transform: translateY(-3px);
            box-shadow: 0 8px 25px rgba(52, 152, 219, 0.4);
        }
        
        .night-tab:hover:not(.active) {
            background: linear-gradient(135deg, rgba(52, 152, 219, 0.7), rgba(41, 128, 185, 0.7));
            color: #ecf0f1;
            transform: translateY(-1px);
        }
        
        .night-tab:hover::before {
            left: 100%;
        }
        
        .night-tab-content {
            display: none;
            background: linear-gradient(135deg, rgba(52, 73, 94, 0.95), rgba(44, 62, 80, 0.95));
            padding: 25px;
            border-radius: 0 0 15px 15px;
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.1);
        }
        
        .night-tab-content.active {
            display: block;
            animation: slideIn 0.3s ease-out;
        }
        
        @keyframes slideIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }
        
        .night-player-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin: 20px 0;
        }
        
        .night-player-item {
            background: linear-gradient(135deg, rgba(52, 73, 94, 0.9), rgba(44, 62, 80, 0.9));
            padding: 15px;
            border-radius: 12px;
            border: 1px solid rgba(149, 165, 166, 0.2);
            font-size: 14px;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            position: relative;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
            overflow: hidden;
        }
        
        .night-player-item::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.1), transparent);
            transition: left 0.5s;
        }
        
        .night-player-item:hover:not(.eliminated):not(.greyed) {
            transform: translateY(-3px);
            background: linear-gradient(135deg, rgba(52, 152, 219, 0.4), rgba(41, 128, 185, 0.4));
            border-color: #3498db;
            box-shadow: 0 8px 25px rgba(52, 152, 219, 0.2);
        }
        
        .night-player-item:hover::before {
            left: 100%;
        }
        
        .night-player-item.eliminated {
            background: linear-gradient(135deg, rgba(231, 76, 60, 0.3), rgba(192, 57, 43, 0.3));
            border-color: #e74c3c;
            text-decoration: line-through;
            opacity: 0.7;
            cursor: not-allowed;
        }
        
        .night-player-item.greyed {
            background: linear-gradient(135deg, rgba(127, 140, 141, 0.3), rgba(108, 117, 125, 0.3));
            border-color: #7f8c8d;
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        .night-player-item.selected {
            background: linear-gradient(135deg, rgba(39, 174, 96, 0.4), rgba(30, 132, 73, 0.4));
            border-color: #27ae60;
            box-shadow: 0 0 20px rgba(39, 174, 96, 0.4);
            transform: translateY(-2px);
        }
        
        .night-role-display {
            color: #f39c12;
            font-weight: bold;
            margin-bottom: 15px;
            text-align: center;
            font-size: 18px;
            padding: 10px;
            background: rgba(243, 156, 18, 0.1);
            border-radius: 10px;
            border: 1px solid rgba(243, 156, 18, 0.3);
        }
        
        /* Method selection buttons */
        .method-buttons {
            display: flex;
            gap: 15px;
            margin: 20px 0;
            justify-content: center;
        }
        
        .method-button {
            background: linear-gradient(135deg, rgba(52, 73, 94, 0.9), rgba(44, 62, 80, 0.9));
            color: #bdc3c7;
            border: 2px solid rgba(149, 165, 166, 0.3);
            padding: 15px 25px;
            border-radius: 12px;
            cursor: pointer;
            font-size: 15px;
            font-weight: bold;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            min-width: 120px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
        }
        
        .method-button:hover:not(:disabled) {
            background: linear-gradient(135deg, rgba(52, 152, 219, 0.4), rgba(41, 128, 185, 0.4));
            border-color: #3498db;
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(52, 152, 219, 0.2);
        }
        
        .method-button.selected {
            background: linear-gradient(135deg, #3498db, #2980b9);
            color: #ecf0f1;
            border-color: #2980b9;
            box-shadow: 0 8px 25px rgba(52, 152, 219, 0.4);
        }

        .method-button:disabled {
            background: linear-gradient(135deg, rgba(52, 73, 94, 0.4), rgba(44, 62, 80, 0.4));
            color: #95a5a6;
            border-color: rgba(149, 165, 166, 0.1);
            cursor: not-allowed;
            opacity: 0.5;
        }
        
        .certainty-buttons {
            display: none;
            gap: 15px;
            margin: 15px 0;
            justify-content: center;
        }
        
   .certainty-button {
    background: linear-gradient(135deg, rgba(127, 140, 141, 0.6), rgba(108, 117, 125, 0.6));
    color: #bdc3c7;
    border: 2px solid rgba(127, 140, 141, 0.4);
    padding: 12px 20px;
    border-radius: 12px;
    cursor: pointer;
    font-size: 14px;
    font-weight: bold;
    transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    min-width: 100px;
    box-shadow: 0 4px 15px rgba(127, 140, 141, 0.2);
}
        
       .certainty-button:hover {
    background: linear-gradient(135deg, rgba(155, 89, 182, 0.8), rgba(142, 68, 173, 0.8));
    border-color: #9b59b6;
    transform: translateY(-2px);
    box-shadow: 0 8px 25px rgba(155, 89, 182, 0.3);
}
        
.certainty-button.selected {
    background: linear-gradient(135deg, #9b59b6, #8e44ad);
    color: #ecf0f1;
    border-color: #8e44ad;
    box-shadow: 0 8px 25px rgba(155, 89, 182, 0.4);
}







@media (max-width: 768px) {
    html {
        font-size: 16px;
    }
    
    body {
        padding: 5px;
        font-size: 16px;
        overflow-x: auto;
    }
    
    .container {
        padding: 15px;
        border-radius: 15px;
        min-width: 800px; /* Forces desktop-like width */
    }
    
    h1 {
        font-size: 2em;
        margin-bottom: 20px;
    }
    
    h2 {
        font-size: 1.2em;
    }
    
    /* All your grid/layout styles - keep these */
    .player-grid,
    .player-inputs-grid,
    .role-assignments-grid,
    .role-grid {
        grid-template-columns: 1fr;
        gap: 12px;
    }
    
    .player-select {
        grid-template-columns: repeat(auto-fit, minmax(130px, 1fr));
    }
    
    .bullet-squares {
        grid-template-columns: 1fr 1fr;
        gap: 15px;
    }

    .bullet-buttons {
        flex-direction: row;
        gap: 10px;
    }
    
    .night-tabs {
        flex-direction: row;
        flex-wrap: wrap;
        padding: 3px;
    }
    
    .night-tab {
        margin: 2px;
        border-radius: 8px;
        padding: 12px 16px;
        font-size: 13px;
    }
    
    .night-player-grid {
        grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
        gap: 12px;
    }
    
    .method-buttons,
    .certainty-buttons {
        flex-direction: row;
        flex-wrap: wrap;
        gap: 10px;
    }
    
    .nav-buttons button {
        width: 100%;
        margin: 8px 0;
        padding: 16px 20px;
    }
    
    .side-by-side-buttons {
        flex-direction: column;
    }
    
    .side-by-side-buttons button {
        max-width: 100%;
        width: 100%;
    }
}

/* DELETE the entire @media (max-width: 480px) section */





 




.page1-title {
    background: none !important;
    -webkit-background-clip: initial !important;
    -webkit-text-fill-color: initial !important;
    background-clip: initial !important;
    color: #e74c3c; /* or any solid color you want for the text */
}

/* Special Abilities Tabs */
.special-ability-tabs {
    display: flex;
    flex-wrap: wrap;
    border-bottom: 3px solid #9b59b6;
    margin-bottom: 25px;
    background: rgba(52, 73, 94, 0.3);
    border-radius: 15px 15px 0 0;
    padding: 5px;
}

.special-ability-tab {
    background: linear-gradient(135deg, rgba(52, 73, 94, 0.8), rgba(44, 62, 80, 0.8));
    border: none;
    padding: 15px 20px;
    margin: 0 3px;
    color: #bdc3c7;
    cursor: pointer;
    border-top-left-radius: 12px;
    border-top-right-radius: 12px;
    font-size: 14px;
    font-weight: 600;
    transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
    position: relative;
    overflow: hidden;
}

.special-ability-tab.used {
    opacity: 0.5;
    text-decoration: line-through;
}

.special-ability-tab.active {
    background: linear-gradient(135deg, #9b59b6, #8e44ad);
    color: #ecf0f1;
    transform: translateY(-3px);
    box-shadow: 0 8px 25px rgba(155, 89, 182, 0.4);
}

.special-ability-tab:hover:not(.active) {
    background: linear-gradient(135deg, rgba(155, 89, 182, 0.7), rgba(142, 68, 173, 0.7));
    color: #ecf0f1;
    transform: translateY(-1px);
}

.special-ability-tab-content {
    display: none;
    background: linear-gradient(135deg, rgba(52, 73, 94, 0.95), rgba(44, 62, 80, 0.95));
    padding: 25px;
    border-radius: 0 0 15px 15px;
    box-shadow: 0 8px 25px rgba(0, 0, 0, 0.1);
}

.special-ability-tab-content.active {
    display: block;
    animation: slideIn 0.3s ease-out;
}

@media (max-width: 768px) {
    .special-ability-tabs {
        flex-direction: row;
        flex-wrap: wrap;
    }
    
    .special-ability-tab {
        margin: 2px;
        padding: 12px 16px;
        font-size: 13px;
    }
}

/* Farsi subtitle styling */
.farsi-subtitle {
    display: block;
    font-size: 1em;
    color: #95a5a6;
    font-weight: bold;
    margin-top: 5px;
    font-style: italic;
}

.role-name .farsi-subtitle {
    font-size: 1em;
    color: #bdc3c7;
}

.night-tab .farsi-subtitle,
.special-ability-tab .farsi-subtitle {
    font-size: 1em;
    color: #95a5a6;
}


.voting-player-card {
    background: linear-gradient(135deg, rgba(52, 73, 94, 0.9), rgba(44, 62, 80, 0.9));
    border: 2px solid rgba(149, 165, 166, 0.3);
    border-radius: 15px;
    padding: 20px;
    margin: 15px 0;
    display: flex;
    align-items: center;
    gap: 20px;
    transition: all 0.3s ease;
}

.voting-player-card.on-trial {
    border-color: #f39c12;
    background: linear-gradient(135deg, rgba(243, 156, 18, 0.3), rgba(230, 126, 34, 0.3));
}

.voting-player-info {
    flex: 1;
    display: flex;
    align-items: center;
    gap: 15px;
}

.voting-checkbox {
    width: 30px;
    height: 30px;
    cursor: pointer;
    accent-color: #f39c12;
}

.voting-player-name {
    font-size: 1.2em;
    font-weight: bold;
    color: #ecf0f1;
    flex: 1;
}

.trial-indicator {
    color: #f39c12;
    font-weight: bold;
    font-size: 1.1em;
    margin-left: 10px;
}

.vote-canvas-container {
    position: relative;
    width: 150px;
    height: 80px;
    background: rgba(236, 240, 241, 0.95);
    border-radius: 10px;
    overflow: hidden;
    box-shadow: inset 0 2px 5px rgba(0, 0, 0, 0.2);
}

.vote-canvas {
    width: 100%;
    height: 100%;
    cursor: crosshair;
    touch-action: none;
}

.clear-canvas-btn {
    position: absolute;
    top: 5px;
    right: 5px;
    width: 25px;
    height: 25px;
    background: #e74c3c;
    border: none;
    border-radius: 50%;
    color: white;
    font-size: 12px;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    padding: 0;
    min-height: unset;
    box-shadow: 0 2px 5px rgba(0, 0, 0, 0.3);
}

.clear-canvas-btn:hover {
    background: #c0392b;
    transform: scale(1.1);
}


/* Side-by-side button layout for voting and history */
.side-by-side-buttons {
    display: flex;
    gap: 5px;
    justify-content: center;
    flex-wrap: wrap;
}

.side-by-side-buttons button {
    width: auto;
    max-width: 175px;
    flex: 1;
    min-width: 150px;
    padding: 15px 20px;
    font-size: 14px;
    margin: 0;
}

@media (max-width: 480px) {
    .side-by-side-buttons {
        flex-direction: column;
    }
    
    .side-by-side-buttons button {
        max-width: 100%;
        width: 100%;
    }
}

    </style>

    </style>



</head>
<body>
    <div class="container">
        <!-- Game Statistics Header (shown on all pages after setup) -->
        <div class="game-stats-header" id="gameStatsHeader" style="display: none;">
            <div id="gameStatsContent">
                <!-- Game statistics will be shown here -->
            </div>
        </div>

        <!-- Page 1: Role Selection -->
        <div class="page active" id="page1">
	    <h1 class="page1-title">🎭 Mafia Game Setup 💣</h1>
            <h2>Select Roles</h2>
            <p class="page-subtitle">Choose how many of each role will be included in this game.</p>

            <div class="role-grid" id="roleGrid">
                <!-- Populated by JavaScript -->
            </div>

            <div class="total-players" id="totalPlayers">
                Total Players: 0
            </div>

            <div class="nav-buttons">
                <button onclick="goToPage(2)" id="nextToPlayers">Next: Enter Players</button>
            </div>
        </div>

        <!-- Page 2: Player Names -->
        <div class="page" id="page2">
            <h1>Enter Player Names</h1>
            <div class="player-inputs-grid" id="playerInputs">
                <!-- Player inputs will be generated by JavaScript -->
            </div>
            <div class="nav-buttons">
                <button onclick="goToPage(1)">Back</button>
                <button onclick="validateAndAssignRoles()" id="nextToAssign">Next: Assign Roles</button>
            </div>
        </div>

        <!-- Page 3: Role Assignment -->
        <div class="page" id="page3">
            <h1>Role Assignments</h1>
            <div class="role-assignments-grid" id="roleAssignments">
                <!-- Role assignments will be generated by JavaScript -->
            </div>
            <div class="nav-buttons">
                <button onclick="goToPage(2)">Back</button>
                <button onclick="goToPage(4)">Next: Day 1 Elimination</button>
            </div>
        </div>

        <!-- Page 4: Day Elimination -->
        <div class="page" id="page4">
            <h1 id="dayTitle"><span class="emoji-icon">☀️</span>Day 1 - Elimination</h1>
            <!-- Day 1 Special Mechanics -->
            <div class="day1-special" id="day1Special" style="display: none;">
		<h2 style="color: #22c1c7; text-align: center;">
 		 Vote like it matters because the Capo’s gun won’t miss
		</h2>
                <div class="bullet-selection">
                    <h3>Mafia Live Bullet Selection:</h3>
                    <div class="bullet-buttons">
                        <button class="bullet-button" id="bullet1Button" onclick="selectBullet('bullet1')">Bullet 1</button>
                        <button class="bullet-button" id="bullet2Button" onclick="selectBullet('bullet2')">Bullet 2</button>
                    </div>
                </div>
                
                <div class="bullet-squares-container">
                    <h3>Drag players into bullet squares:</h3>
                    <div class="bullet-squares">
                        <div class="bullet-square-wrapper">
                            <div class="bullet-label-top">Bullet 1</div>
                            <div class="bullet-square" id="bullet1Square" data-bullet="bullet1">
                                <div class="drop-zone">Drop player here</div>
                            </div>
                        </div>
                        <div class="bullet-square-wrapper">
                            <div class="bullet-label-top">Bullet 2</div>
                            <div class="bullet-square" id="bullet2Square" data-bullet="bullet2">
                                <div class="drop-zone">Drop player here</div>
                            </div>
                        </div>
                    </div>
                </div>
                
                <!-- Player Pool with Names and Roles -->
                <div class="player-list-header">
                    <h3>Players</h3>
                    <div class="player-grid" id="day1PlayersGrid">
                        <!-- Players will be populated here -->
                    </div>
                </div>
                
                <div id="bulletResult"></div>
            </div>

            <div class="elimination-section" id="eliminationSection">
                <h2>Select a player to eliminate:</h2>
                
                <!-- Player Pool for Day 2+ -->
                <div class="player-list-header" id="day2PlusPlayersHeader" style="display: none;">
                    <h3>Players</h3>
                    <div class="player-grid" id="day2PlusPlayersGrid">
                        <!-- Players will be populated here -->
                    </div>
                </div>
                
                <div id="dayEliminatedRole"></div>
            </div>

           <div class="nav-buttons">
    <button id="toggleRolesBtn" onclick="toggleAllRoles()">Hide Roles</button>
    <div class="side-by-side-buttons">
        <button id="votingBtn" onclick="showVotingPage()" style="display: none; background: linear-gradient(135deg, #f39c12, #e67e22) !important; box-shadow: 0 6px 20px rgba(243, 156, 18, 0.3) !important;">Open Voting</button>
        <button id="viewHistoryBtn" onclick="showNightHistory()" style="display: none; background: linear-gradient(135deg, #95a5a6, #7f8c8d) !important; box-shadow: 0 6px 20px rgba(149, 165, 166, 0.3) !important;">View Game History</button>
    </div>
    <button onclick="goToNight()">Next: Night Actions</button>
</div>
            
        </div>

        <!-- Page 5: Night Actions -->
        <div class="page" id="page5">
            <h1 id="nightTitle"><span class="emoji-icon">🌙</span>Night 1</h1>
            
            <!-- Night Tabs -->
            <div class="night-tabs" id="nightTabs">
                <!-- Tabs will be generated by JavaScript -->
            </div>
            
            <div id="nightTabsContent">
                <!-- Tab contents will be generated by JavaScript -->
            </div>
            
            <div class="nav-buttons">
                <button onclick="processNight()">Process Night & Continue</button>
            </div>
        </div>

        <!-- Page 6: Night Summary -->
        <div class="page" id="page6">
            <h1 id="summaryTitle">Night 1 Summary</h1>
            <div id="nightResults">
                <!-- Night results will be shown here -->
            </div>
            <div class="elimination-summary" id="eliminationSummary" style="display: none;">
                <!-- Elimination summary will be shown here -->
            </div>
            <div class="nav-buttons">
                <button onclick="revealEliminationCount()" id="revealBtn">Reveal Elimination Count</button>
                <button onclick="showNightHistory()" style="background: linear-gradient(135deg, #95a5a6, #7f8c8d) !important; box-shadow: 0 6px 20px rgba(149, 165, 166, 0.3) !important;">View Game History</button>
                <button onclick="goToNextDay()">Next Day</button>
            </div>
        </div>
    </div>

<!-- Page 7: Master of Disguise Transformation -->
        <div class="page" id="page7">
            <h1>🎭 Role Transformation</h1>
            <div style="text-align: center; padding: 40px 20px;">
                <div style="background: linear-gradient(135deg, rgba(155, 89, 182, 0.3), rgba(142, 68, 173, 0.3)); 
                            border: 3px solid #9b59b6; 
                            border-radius: 20px; 
                            padding: 40px; 
                            margin: 20px auto; 
                            max-width: 600px;
                            box-shadow: 0 10px 40px rgba(155, 89, 182, 0.4);">
                    <h2 style="color: #ecf0f1; font-size: 2em; margin-bottom: 20px;">
                        Hey Master of Disguise!
                    </h2>
                    <p style="font-size: 1.5em; color: #f1c40f; font-weight: bold; margin: 30px 0;">
                        Your new role is:
                    </p>
                    <div id="modNewRole" style="font-size: 2.5em; 
                                                 color: #e74c3c; 
                                                 font-weight: bold; 
                                                 margin: 20px 0;
                                                 text-shadow: 0 0 20px rgba(231, 76, 60, 0.5);">
                        <!-- Role will be inserted here -->
                    </div>
                </div>
            </div>
            <div class="nav-buttons">
                <button onclick="continueToNightActions()">Continue to Night Actions</button>
            </div>
        </div>

<!-- Page 8: Special Day Abilities -->
<div class="page" id="page8">
<h1>Use Your Final Move</h1>
<p class="page-subtitle">Use these powerful one-time abilities wisely! This is your last chance.</p>

<!-- Tabs Container -->
<div class="special-ability-tabs" id="specialAbilityTabs">
    <!-- Tabs will be generated by JavaScript -->
</div>

<div id="specialAbilityTabsContent">
    <!-- Tab contents will be generated by JavaScript -->
</div>

<div class="nav-buttons">
    <button onclick="confirmSpecialAbilities()">Confirm & Continue to Night</button>
</div>
</div>

<!-- Page 9: Night History -->
<div class="page" id="page9">
    <h1>📜 Complete Game History</h1>
    <p class="page-subtitle">Review all day and night events from the beginning of the game</p>
    <div id="nightHistoryContent" style="max-height: 70vh; overflow-y: auto;">
        <!-- History will be populated here -->
    </div>
    <div class="nav-buttons">
        <button onclick="goToPage(6)">Back to Current Night</button>
    </div>
</div>


<!-- Page 10: Game Over -->
<div class="page" id="page10">
    <div style="text-align: center; padding: 40px 20px;">
        <div id="winnerDisplay" style="background: linear-gradient(135deg, rgba(241, 196, 15, 0.3), rgba(243, 156, 18, 0.3)); 
                    border: 3px solid #f1c40f; 
                    border-radius: 20px; 
                    padding: 60px 40px; 
                    margin: 40px auto; 
                    max-width: 800px;
                    box-shadow: 0 15px 50px rgba(241, 196, 15, 0.5);">
            <h1 style="font-size: 3.5em; margin-bottom: 30px; color: #f1c40f; text-shadow: 0 0 30px rgba(241, 196, 15, 0.6);">
                🎉 Game Over 🎉
            </h1>
            <div id="winMessage" style="font-size: 2em; color: #ecf0f1; font-weight: bold; margin: 30px 0;">
                <!-- Win message will be inserted here -->
            </div>
            <div id="finalStats" style="margin-top: 40px; font-size: 1.2em; color: #bdc3c7; line-height: 1.8;">
                <!-- Final statistics will be inserted here -->
            </div>
        </div>
    </div>
    <div class="nav-buttons">
   <button onclick="showNightHistory()" style="background: linear-gradient(135deg, #95a5a6, #7f8c8d) !important; 
                                                     box-shadow: 0 6px 20px rgba(149, 165, 166, 0.3) !important;">
            View Game History
        </button>
        <button onclick="startOver()" style="background: linear-gradient(135deg, #e74c3c, #c0392b) !important; 
                                           box-shadow: 0 6px 20px rgba(231, 76, 60, 0.4) !important;
                                           font-size: 18px;
                                           padding: 20px 40px;">
            🔄 Start New Game
        </button>
    </div>
</div>



<!-- Page 11: Voting Interface -->
<div class="page" id="page11">
    <h1>🗳️ Voting Interface</h1>
    <p class="page-subtitle">Select players on trial and record their votes</p>
    
    <div id="votingPlayersList" style="max-width: 800px; margin: 0 auto;">
        <!-- Players will be populated here -->
    </div>
    
    <div class="nav-buttons">
        <button onclick="goToPage(4)">Back to Day Elimination</button>
    </div>
</div>



 <script>
        // Game state object
        const gameState = {
            roles: {
                'Jailer': 1,
                'Godfather - Mafia': 1,
                'Executioner - Mafia': 1,
                'Regular Mafia': 0,
                'Shooter': 1,
                'Doctor': 1,
                'Psychiatrist': 1,
                'Detective': 1,
                'Ghost': 1,
                'Master of Disguise': 0,
                'Civilian': 0,
                'Devotee': 1
            },
            players: [],
            assignments: {},
            eliminated: [],
	    playersWhoUsedSpecialAbility: [],
            currentPage: 1,
            dayNumber: 1,
            nightNumber: 1,
            jailerUsesLeft: 2,
            doctorSelfSaveUsed: false,
            shooterUsesLeft: 2,
            shooterShieldActive: true,
            godfatherShieldActive: true,
            godfatherAttackCount: 0,
            masterOfDisguiseSelection: null,
            masterOfDisguiseTransformed: false,
            eliminationCountRevealsLeft: 2,
	    devoteeUsesLeft: 2,
	    psychiatristUsesLeft: 2,
            eliminationCountRevealed: false,
            lockedPlayer: null,
            lockAbilityUsed: false,
	    additionalEliminationUsed: false,
	    roleSwapUsed: false,
            jailedPlayers: {},
            selectedForElimination: null,
            modTransformation: null,
            previousPage: 1,
            savedThisNight: [],
            nightSelections: {}, // Store night selections per role
            selectedBullet: null // New property to track selected bullet
        };

// Farsi translations
const farsiTranslations = {
    roles: {
        'Jailer': 'زندانبان',
        'Godfather - Mafia': 'پدرخوانده مافیا',
        'Executioner - Mafia': 'جلاد مافیا',
        'Regular Mafia': 'مافیای ساده',
        'Shooter': 'تیرانداز',
        'Doctor': 'داکتر',
        'Psychiatrist': 'روانپزشک',
        'Detective': 'کارآگاه',
        'Ghost': 'روح',
        'Master of Disguise': 'هزار چهره',
        'Civilian': 'شهروند ساده',
        'Devotee': 'فداکار'
    },
    nightTabs: {
        'Jailer': 'زندانبان',
        'Mafia': 'مافیا',
        'Doctor': 'داکتر',
        'Shooter': 'تیرانداز',
        'Detective': 'کارآگاه',
        'Devotee': 'فداکار',
        'Psychiatrist': 'روانپزشک',
        'Master of Disguise': 'هزار چهره'
    },
    specialAbilities: {
        'Handcuffs': 'دستبند',
        'Additional Elimination': 'سلاخی',
        'Guess the Role': 'ذهن زیبا',
        'Reveal Your Role': 'افشای هویت',
        'Mute Player': 'سکوت',
        'Trial': 'دفاعیه'
    }
};


        const defaultNames = [
            "Reza Nazari", "Khodadad Ahmadi", "Ahmad Taheri", "Alireza Jafari", 
            "Hamid Shahabi", "Sayed Ahmad", "Haidar Fazeli", "Asef Ghafori", 
            "Jafar Nazari", "Qomandan"
        ];



function checkWinCondition() {
    const alivePlayers = gameState.players.filter(p => !gameState.eliminated.includes(p));
    const aliveMafia = alivePlayers.filter(p => 
        ['Godfather - Mafia', 'Executioner - Mafia', 'Regular Mafia'].includes(gameState.assignments[p])
    ).length;

    const aliveNonMafia = alivePlayers.length - aliveMafia;

    if (aliveMafia === 0) {
        showGameOver('town');
        return true;
    } 
    if (aliveMafia >= aliveNonMafia) {
        showGameOver('mafia');
        return true;
    }
    return false;
}


        // Update game statistics header (shown on all pages after night 1)
        function updateGameStatsHeader() {
            const header = document.getElementById('gameStatsHeader');
            const content = document.getElementById('gameStatsContent');
            
            if (gameState.nightNumber > 1 || gameState.currentPage >= 5) {
                const alivePlayers = gameState.players.filter(p => !gameState.eliminated.includes(p));
                const aliveRoles = {};
                const eliminatedRoles = {};
                
                alivePlayers.forEach(player => {
                    const role = gameState.assignments[player];
                    if (!aliveRoles[role]) aliveRoles[role] = 0;
                    aliveRoles[role]++;
                });
                
                gameState.eliminated.forEach(player => {
                    const role = gameState.assignments[player];
                    if (!eliminatedRoles[role]) eliminatedRoles[role] = 0;
                    eliminatedRoles[role]++;
                });
                
                const aliveMafia = (aliveRoles['Godfather - Mafia'] || 0) + 
                                  (aliveRoles['Executioner - Mafia'] || 0) + 
                                  (aliveRoles['Regular Mafia'] || 0);
                
                const aliveNonMafia = alivePlayers.length - aliveMafia;
                
                const eliminatedMafia = (eliminatedRoles['Godfather - Mafia'] || 0) + 
                                       (eliminatedRoles['Executioner - Mafia'] || 0) + 
                                       (eliminatedRoles['Regular Mafia'] || 0);
                
                const eliminatedNonMafia = gameState.eliminated.length - eliminatedMafia;

   		content.innerHTML = `
                   <strong>Day ${gameState.dayNumber} | Night ${gameState.nightNumber}</strong><br>
    		   <strong>Total alive players = ${alivePlayers.length}</strong><br>
                   <strong>Total eliminated players = ${gameState.eliminated.length}</strong><br>
                   <strong>Votes Needed = ${Math.ceil(alivePlayers.length / 2)}</strong><br>
                `;
                
                
                header.style.display = 'block';
            } else {
                header.style.display = 'none';
            }
        }

        // Initialize role selection grid
        function initializeRoleSelection() {
            console.log("Initializing role selection...");
            const roleGrid = document.getElementById('roleGrid');
            
            if (!roleGrid) {
                console.error("Role grid not found!");
                return;
            }
            
            roleGrid.innerHTML = '';
            
            Object.keys(gameState.roles).forEach(role => {
                const roleItem = document.createElement('div');
                roleItem.className = 'role-item';
                
                const maxValue = (role === 'Regular Mafia' || role === 'Civilian') ? 10 : 1;
                const currentValue = gameState.roles[role];
                
 roleItem.innerHTML = `
    <span class="role-name">${role}<span class="farsi-subtitle">${farsiTranslations.roles[role] || ''}</span></span>
    <div class="counter">
        <button class="counter-btn" onclick="changeRoleCount('${role}', -1)">−</button>
        <span class="counter-value" id="${role.replace(/\s+/g, '')}Count">${currentValue}</span>
        <button class="counter-btn" onclick="changeRoleCount('${role}', 1)">+</button>
    </div>
`;
                roleGrid.appendChild(roleItem);
            });
            
            updateTotalPlayers();
            console.log("Role selection initialized successfully");
        }

        // Update role count when user changes input
        function updateRoleCount(role, value) {
            const numValue = parseInt(value) || 0;
            gameState.roles[role] = numValue;
            updateTotalPlayers();
        }

function changeRoleCount(role, delta) {
    const maxValue = (role === 'Regular Mafia' || role === 'Civilian') ? 10 : 1;
    let currentValue = gameState.roles[role] || 0;
    currentValue = Math.max(0, Math.min(maxValue, currentValue + delta));
    gameState.roles[role] = currentValue;
    document.getElementById(role.replace(/\s+/g, '') + 'Count').textContent = currentValue;
    updateTotalPlayers();
}

        // Update total player count display
        function updateTotalPlayers() {
            const total = Object.values(gameState.roles).reduce((sum, count) => sum + count, 0);
            const totalElement = document.getElementById('totalPlayers');
            if (totalElement) {
                totalElement.textContent = `Total Players: ${total}`;
            }
        }

        // Navigate between pages
        function goToPage(pageNum) {
            gameState.previousPage = gameState.currentPage;
            
            document.querySelectorAll('.page').forEach(page => {
                page.classList.remove('active');
            });
            
            const targetPage = document.getElementById(`page${pageNum}`);
            if (targetPage) {
                targetPage.classList.add('active');
                gameState.currentPage = pageNum;
                
                updateGameStatsHeader();
                
                if (pageNum === 2) {
                    generatePlayerInputs();
                } else if (pageNum === 3) {
               
                } else if (pageNum === 4) {
                    setupDayElimination();
                } else if (pageNum === 5) {
                    setupNightActions();
                }
            }
        }

// Generate player input fields
function generatePlayerInputs() {
    const totalPlayers = Object.values(gameState.roles).reduce((sum, count) => sum + count, 0);
    const totalInputs = totalPlayers + 1; // Add one extra for host
    const playerInputsContainer = document.getElementById('playerInputs');
    
    if (!playerInputsContainer) return;
    
    playerInputsContainer.innerHTML = '';
    
    // Add host dropdown
    const hostSelectionDiv = document.createElement('div');
    hostSelectionDiv.style.cssText = `
        background: linear-gradient(135deg, rgba(241, 196, 15, 0.2), rgba(243, 156, 18, 0.2));
        border: 2px solid #f1c40f;
        border-radius: 15px;
        padding: 20px;
        margin-bottom: 25px;
        grid-column: 1 / -1;
    `;
    hostSelectionDiv.innerHTML = `
        <label style="display: block; text-align: center; font-weight: bold; font-size: 1.2em; margin-bottom: 15px;">
            👑 Name Yourself, Oh Mighty Game Master!
        </label>
        <select id="hostSelect" style="width: 100%; max-width: 400px; margin: 0 auto; display: block; font-size: 1.1em;">
            <option value="">-- No Host Selected --</option>
        </select>
    `;
    playerInputsContainer.appendChild(hostSelectionDiv);
    
    const sortedDefaultNames = [...defaultNames].sort();
    
    for (let i = 0; i < totalInputs; i++) {
        const inputDiv = document.createElement('div');
        inputDiv.className = 'player-input';
        
        const defaultName = i < sortedDefaultNames.length ? sortedDefaultNames[i] : `Player ${i + 1}`;
        
        inputDiv.innerHTML = `
            <label>Person ${i + 1}:</label>
            <input type="text" id="player${i}" value="${defaultName}">
        `;
        playerInputsContainer.appendChild(inputDiv);
        
        // Add option to host dropdown
        const hostSelect = document.getElementById('hostSelect');
        const option = document.createElement('option');
        option.value = i;
        option.textContent = defaultName;
        option.id = `hostOption${i}`;
        hostSelect.appendChild(option);
    }
    
    // Update dropdown options when input fields change
    for (let i = 0; i < totalInputs; i++) {
        const input = document.getElementById(`player${i}`);
        input.addEventListener('input', function() {
            const hostOption = document.getElementById(`hostOption${i}`);
            if (hostOption) {
                hostOption.textContent = this.value || `Player ${i + 1}`;
            }
        });
    }
}

  // Assign roles to players
function assignRoles() {
    gameState.players = [];
    const totalPlayers = Object.values(gameState.roles).reduce((sum, count) => sum + count, 0);
    
    // Get the host selection
    const hostSelect = document.getElementById('hostSelect');
    const hostIndex = hostSelect ? parseInt(hostSelect.value) : -1;
    
    // Validate host selection
    if (hostIndex === -1 || isNaN(hostIndex)) {
        alert('Please select a HOST before proceeding!');
        return;
    }
    
    // Collect all player names except the host
    for (let i = 0; i < totalPlayers + 1; i++) {
        if (i === hostIndex) continue; // Skip the host
        
        const playerInput = document.getElementById(`player${i}`);
        if (playerInput) {
            const name = playerInput.value.trim();
            if (name) {
                gameState.players.push(name);
            }
        }
    }
    
    // Verify we have the right number of players
    if (gameState.players.length !== totalPlayers) {
        alert(`Error: Expected ${totalPlayers} players (excluding host), but got ${gameState.players.length}. Please check your inputs.`);
        return;
    }
    
    gameState.players.sort();
    
    let rolePool = [];
    Object.entries(gameState.roles).forEach(([role, count]) => {
        if (count > 0) {
            for (let i = 0; i < count; i++) {
                rolePool.push(role);
            }
        }
    });
    
    rolePool = shuffleArray(rolePool);
    gameState.assignments = {};
    gameState.players.forEach((player, index) => {
        if (index < rolePool.length) {
            gameState.assignments[player] = rolePool[index];
        }
    });
    
    displayRoleAssignments();
}

// Shuffle array function
function shuffleArray(array) {
    const shuffled = [...array];
    for (let i = shuffled.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
    }
    return shuffled;
}

// Display role assignments with reveal buttons
function displayRoleAssignments() {
    const container = document.getElementById('roleAssignments');
    if (!container) return;
    
    container.innerHTML = '';
    
    gameState.players.forEach(player => {
        const item = document.createElement('div');
        item.className = 'player-role-item';
        
        item.innerHTML = `
            <span><strong>${player}</strong></span>
            <div>
                <span class="hidden-role" id="role-${player}">Click to reveal role</span>
                <button class="role-reveal" onclick="toggleRole('${player}')">Reveal</button>
            </div>
        `;
        container.appendChild(item);
    });
}

// Validate host selection before assigning roles
function validateAndAssignRoles() {
    const hostSelect = document.getElementById('hostSelect');
    const hostIndex = hostSelect ? parseInt(hostSelect.value) : -1;
    
    if (hostIndex === -1 || isNaN(hostIndex)) {
        alert('⚠️ Please select a HOST from the dropdown before proceeding!');
        return;
    }
    
    // First assign roles, THEN navigate to page 3
    assignRoles();
    goToPage(3);
}


       // Toggle role visibility
function toggleRole(player) {
    const roleSpan = document.getElementById(`role-${player}`);
    const button = roleSpan.nextElementSibling;
    
    if (!roleSpan || !button) return;
    
    gameState.players.forEach(p => {
        if (p !== player) {
            const otherRoleSpan = document.getElementById(`role-${p}`);
            const otherButton = otherRoleSpan ? otherRoleSpan.nextElementSibling : null;
            if (otherRoleSpan && otherButton) {
                otherRoleSpan.textContent = 'Click to reveal role';
                otherRoleSpan.className = 'hidden-role';
                otherButton.textContent = 'Reveal';
                otherButton.className = 'role-reveal';
            }
        }
    });
    
    if (roleSpan.classList.contains('hidden-role')) {
        const role = gameState.assignments[player] || 'No role assigned';
        const farsiRole = farsiTranslations.roles[role] || '';
        
        // Display both English and Farsi
        roleSpan.innerHTML = farsiRole 
            ? `${role}<br><span style="color: #95a5a6; font-weight: bold; font-size: 16px;">(${farsiRole})</span>`
            : role;
        
        roleSpan.className = '';
        button.textContent = 'Hide';
        button.className = 'role-reveal role-revealed';
    } else {
        roleSpan.textContent = 'Click to reveal role';
        roleSpan.className = 'hidden-role';
        button.textContent = 'Reveal';
        button.className = 'role-reveal';
    }
}

        // Setup Day Elimination
        function setupDayElimination() {
		document.getElementById('dayTitle').innerHTML = `<span class="emoji-icon">☀️</span>Day ${gameState.dayNumber} - Elimination`;
            if (gameState.dayNumber === 1) {
                document.getElementById('day1Special').style.display = 'block';
                document.getElementById('eliminationSection').style.display = 'none';
                setupDay1Mechanics();
            } else {
                document.getElementById('day1Special').style.display = 'none';
                document.getElementById('eliminationSection').style.display = 'block';
                setupDay2PlusElimination();
            }
	// Show "View Night History" button starting from Day 2
            // Show "View Night History" button if there's any history
const historyBtn = document.getElementById('viewHistoryBtn');
if (historyBtn) {
    const hasHistory = (gameState.dayHistory && gameState.dayHistory.length > 0) || 
                       (gameState.nightHistory && gameState.nightHistory.length > 0);
    if (hasHistory) {
        historyBtn.style.display = 'inline-block';
    } else {
        historyBtn.style.display = 'none';
	
    }
}
 updateVotingButtonVisibility();
        }


        function setupDay1Mechanics() {
            setupDay1PlayersGrid();
            setupDropZones();
        }

        // New function to handle bullet selection 
	function selectBullet(bullet) {
 	   const currentSelected = gameState.selectedBullet;

	    // If the clicked bullet is already selected, unselect it
	    if (currentSelected === bullet) {
	        document.getElementById(bullet + 'Button').classList.remove('selected');
 	       gameState.selectedBullet = null;
	       bullet1Square.classList.remove('elimination-target');
	       bullet2Square.classList.remove('elimination-target');
	       checkBulletMatch();
        return; // Exit early
    }

  	  // Otherwise, proceed with new selection
  	  document.getElementById('bullet1Button').classList.remove('selected');
  	  document.getElementById('bullet2Button').classList.remove('selected');
  	  document.getElementById(bullet + 'Button').classList.add('selected');
  	  gameState.selectedBullet = bullet;
	
   	 checkBulletMatch();
	}

        function setupDay1PlayersGrid() {
            const container = document.getElementById('day1PlayersGrid');
            container.innerHTML = '';
            
            // Make the container a drop zone for players being dragged back
            container.addEventListener('dragover', (e) => {
                e.preventDefault();
                container.style.backgroundColor = 'rgba(39, 174, 96, 0.2)';
                container.style.borderColor = '#27ae60';
            });
            
            container.addEventListener('dragleave', (e) => {
                if (!container.contains(e.relatedTarget)) {
                    container.style.backgroundColor = 'rgba(52, 152, 219, 0.2)';
                    container.style.borderColor = '#3498db';
                }
            });
            
            container.addEventListener('drop', (e) => {
                e.preventDefault();
                const player = e.dataTransfer.getData('text/plain');
                
                removePlayerFromAllLocations(player);
                
                const playerDiv = container.querySelector(`[data-player="${player}"]`);
                if (!playerDiv) {
                    addPlayerToGrid(player, container);
                }
                
                container.style.backgroundColor = 'rgba(52, 152, 219, 0.2)';
                container.style.borderColor = '#3498db';
                
                checkBulletMatch();
            });
            
            gameState.players.forEach(player => {
                addPlayerToGrid(player, container);
            });
        }

function setupDay2PlusElimination() {
    const header = document.getElementById('day2PlusPlayersHeader');
    const container = document.getElementById('day2PlusPlayersGrid');
    
    header.style.display = 'block';
    container.innerHTML = '';
    
    gameState.players.forEach(player => {
        const playerDiv = document.createElement('div');
        playerDiv.className = 'player-item';
        playerDiv.dataset.player = player;
        
        if (gameState.eliminated.includes(player)) {
            playerDiv.classList.add('eliminated');
        } else {
            playerDiv.onclick = () => selectForElimination(player);
        }
        
        const role = gameState.assignments[player] || 'No role';
        const isSilenced = gameState.silencedPlayers && gameState.silencedPlayers.includes(player);
        const isOnTrial = gameState.trialPlayer === player;
	playerDiv.innerHTML = `
    <strong>${player}</strong>
    ${isSilenced ? '<span style="color: #9b59b6; font-size: 16px; margin-left: 8px;" title="Player is silenced">🔇</span>' : ''}
    ${isOnTrial ? '<span style="color: #f39c12; font-size: 16px; margin-left: 8px;" title="Player is on trial">⚖️</span>' : ''}
    <br>
    <span style="color: #95a5a6; font-size: 12px;">${role}${farsiTranslations.roles[role] ? ` (${farsiTranslations.roles[role]})` : ''}</span>
`;
        container.appendChild(playerDiv);
    });
}

    function addPlayerToGrid(player, container) {
    const playerDiv = document.createElement('div');
    playerDiv.className = 'player-item';
    playerDiv.textContent = player;
    playerDiv.draggable = true;
    playerDiv.dataset.player = player;
    
    const role = gameState.assignments[player] || 'No role';
    const farsiRole = farsiTranslations.roles[role] || '';
    const isSilenced = gameState.silencedPlayers && gameState.silencedPlayers.includes(player);

    playerDiv.innerHTML = `
        <strong>${player}</strong>
        ${isSilenced ? '<span style="color: #9b59b6; font-size: 16px; margin-left: 8px;" title="Player is silenced">🔇</span>' : ''}
        <br>
        <span style="color: #95a5a6; font-size: 12px;">${role}${farsiRole ? ` (${farsiRole})` : ''}</span>
    `;
    
  
    
    playerDiv.addEventListener('dragstart', (e) => {
        e.dataTransfer.setData('text/plain', player);
        playerDiv.classList.add('dragging');
    });
    
    playerDiv.addEventListener('dragend', () => {
        playerDiv.classList.remove('dragging');
    });
    
    container.appendChild(playerDiv);
}

        function setupDropZones() {
            const bullet1Square = document.getElementById('bullet1Square');
            const bullet2Square = document.getElementById('bullet2Square');
            
            [bullet1Square, bullet2Square].forEach(square => {
                square.addEventListener('dragover', (e) => {
                    e.preventDefault();
                    square.classList.add('drag-over');
                });
                
                square.addEventListener('dragleave', (e) => {
                    square.classList.remove('drag-over');
                });
                
                square.addEventListener('drop', (e) => {
                    e.preventDefault();
                    square.classList.remove('drag-over');
                    
                    const player = e.dataTransfer.getData('text/plain');
                    
                    const existingPlayerInSquare = square.querySelector('.player-in-square');
                    let displacedPlayer = null;
                    
                    if (existingPlayerInSquare) {
                        displacedPlayer = existingPlayerInSquare.dataset.player;
                    }
                    
                    removePlayerFromAllLocations(player);
                    
                    addPlayerToSquare(square, player);
                    
                    if (displacedPlayer && displacedPlayer !== player) {
                        addPlayerToGrid(displacedPlayer, document.getElementById('day1PlayersGrid'));
                    }
                    
                    checkBulletMatch();
                });
                
                square.addEventListener('click', (e) => {
                    if (e.target.classList.contains('player-in-square')) {
                        const player = e.target.dataset.player;
                        removePlayerFromSquare(square);
                        addPlayerToGrid(player, document.getElementById('day1PlayersGrid'));
                        checkBulletMatch();
                    }
                });
            });
        }

        function removePlayerFromAllLocations(player) {
            // Remove from grid
            const grids = [document.getElementById('day1PlayersGrid')];
            grids.forEach(grid => {
                if (grid) {
                    const playerDiv = grid.querySelector(`[data-player="${player}"]`);
                    if (playerDiv) {
                        playerDiv.remove();
                    }
                }
            });
            
            // Remove from squares
            const squares = [document.getElementById('bullet1Square'), document.getElementById('bullet2Square')];
            squares.forEach(square => {
                const existingPlayer = square.querySelector('.player-in-square');
                if (existingPlayer && existingPlayer.dataset.player === player) {
                    removePlayerFromSquare(square);
                }
            });
        }

     function addPlayerToSquare(square, player) {
    removePlayerFromSquare(square);
    
    const role = gameState.assignments[player] || 'No role';
    const farsiRole = farsiTranslations.roles[role] || '';
    const playerDiv = document.createElement('div');
    playerDiv.className = 'player-in-square';
    playerDiv.innerHTML = `
        <strong>${player}</strong><br>
        <span style="font-size: 10px; color: #7f8c8d;">${role}${farsiRole ? ` (${farsiRole})` : ''}</span>
    `;
    playerDiv.dataset.player = player;
  
            playerDiv.title = 'Click to remove or drag back to player pool';
            playerDiv.draggable = true;
            
            playerDiv.addEventListener('dragstart', (e) => {
                e.dataTransfer.setData('text/plain', player);
                playerDiv.classList.add('dragging');
            });
            
            playerDiv.addEventListener('dragend', () => {
                playerDiv.classList.remove('dragging');
            });
            
            square.appendChild(playerDiv);
            square.classList.add('has-player');
            
            const dropZone = square.querySelector('.drop-zone');
            if (dropZone) dropZone.style.display = 'none';
        }

        function removePlayerFromSquare(square) {
            const existingPlayer = square.querySelector('.player-in-square');
            if (existingPlayer) {
                const player = existingPlayer.dataset.player;
                existingPlayer.remove();
                square.classList.remove('has-player');
                
                const dropZone = square.querySelector('.drop-zone');
                if (dropZone) dropZone.style.display = 'block';
                
                return player;
            }
            return null;
        }

        function checkBulletMatch() {
            const selectedBullet = gameState.selectedBullet;
            const resultDiv = document.getElementById('bulletResult');
            const bullet1Square = document.getElementById('bullet1Square');
            const bullet2Square = document.getElementById('bullet2Square');
            const bullet1Wrapper = bullet1Square.closest('.bullet-square-wrapper');
            const bullet2Wrapper = bullet2Square.closest('.bullet-square-wrapper');
            bullet1Square.classList.remove('elimination-target');
            bullet2Square.classList.remove('elimination-target');
            bullet1Wrapper.querySelector('.bullet-label-top').style.color = '#3498db';
            bullet2Wrapper.querySelector('.bullet-label-top').style.color = '#3498db';
            
            if (!selectedBullet) {
                resultDiv.innerHTML = '';
                return;
            }
            
            const matchingSquare = document.getElementById(selectedBullet + 'Square');
            const matchingWrapper = matchingSquare.closest('.bullet-square-wrapper');
            const playerInSquare = matchingSquare ? matchingSquare.querySelector('.player-in-square') : null;
            
            if (playerInSquare) {
                const player = playerInSquare.dataset.player;
                const playerRole = gameState.assignments[player];
                
                matchingSquare.classList.add('elimination-target');
                matchingWrapper.querySelector('.bullet-label-top').style.color = '#e74c3c';
                
                resultDiv.innerHTML = `<div class="eliminated-role">${player} - ${playerRole} is in ${selectedBullet.charAt(0).toUpperCase() + selectedBullet.slice(1)} and will be eliminated!</div>`;
            } else {
                resultDiv.innerHTML = `<div style="background: rgba(39, 174, 96, 0.2); border: 2px solid #27ae60; padding: 15px; margin-top: 20px; border-radius: 10px; text-align: center; font-size: 18px;">No player in ${selectedBullet.charAt(0).toUpperCase() + selectedBullet.slice(1)} - no elimination!</div>`;
            }
        }

        function selectForElimination(player) {
       
            document.querySelectorAll('#day2PlusPlayersGrid .player-item').forEach(item => {
                item.classList.remove('selected');
                item.style.backgroundColor = '';
            });
            
            if (gameState.selectedForElimination === player) {
                gameState.selectedForElimination = null;
                document.getElementById('dayEliminatedRole').innerHTML = '';
            } else {
                gameState.selectedForElimination = player;
                const playerDiv = document.querySelector(`#day2PlusPlayersGrid [data-player="${player}"]`);
                if (playerDiv) {
                    playerDiv.style.backgroundColor = 'rgba(231, 76, 60, 0.4)';
                }
                
                document.getElementById('dayEliminatedRole').innerHTML = `
                    <div class="eliminated-role">
                        ${player} - ${gameState.assignments[player]}
                    </div>
                `;
            }
            
            const roleSwapSelect = document.getElementById('roleSwapSelect');
            if (roleSwapSelect && roleSwapSelect.value) {
                const resultDiv = document.getElementById('roleSwapResult');
                if (gameState.selectedForElimination) {
                    resultDiv.innerHTML = `
                        <div class="eliminated-role">
                            ${gameState.selectedForElimination}'s role will be swapped with ${roleSwapSelect.value}
                        </div>
                    `;
                }
            }
        }

        function setupLockAbility() {
            const alivePlayers = gameState.players.filter(p => !gameState.eliminated.includes(p));
            const select = document.getElementById('lockAbilitySelect');
            
            select.innerHTML = '<option value="">Select player to lock</option>';
            
            alivePlayers.forEach(player => {
                const option = document.createElement('option');
                option.value = player;
                option.textContent = player;
                select.appendChild(option);
            });
            
            select.onchange = function() {
                const selectedPlayer = this.value;
                const resultDiv = document.getElementById('lockedPlayer');
                
                if (selectedPlayer) {
                    gameState.lockedPlayer = selectedPlayer;
                    resultDiv.innerHTML = `
                        <div class="eliminated-role">
                            ${selectedPlayer}'s ability will be locked for the next night
                        </div>
                    `;
                } else {
                    gameState.lockedPlayer = null;
                    resultDiv.innerHTML = '';
                }
            };
        }

        function setupAdditionalElimination() {
            const alivePlayers = gameState.players.filter(p => !gameState.eliminated.includes(p));
            const select = document.getElementById('additionalEliminationSelect');
            
            select.innerHTML = '<option value="">No additional elimination</option>';
            
            alivePlayers.forEach(player => {
                const option = document.createElement('option');
                option.value = player;
                option.textContent = player;
                select.appendChild(option);
            });
            
            select.onchange = function() {
                const selectedPlayer = this.value;
                const resultDiv = document.getElementById('additionalEliminatedPlayer');
                
                if (selectedPlayer) {
                    resultDiv.innerHTML = `
                        <div class="eliminated-role">
                            ${selectedPlayer} will be additionally eliminated
                        </div>
                    `;
                } else {
                    resultDiv.innerHTML = '';
                }
            };
        }

        function setupRoleSwap() {
            const alivePlayers = gameState.players.filter(p => !gameState.eliminated.includes(p));
            const select = document.getElementById('roleSwapSelect');
            
            select.innerHTML = '<option value="">No role swap</option>';
            
            alivePlayers.forEach(player => {
                const option = document.createElement('option');
                option.value = player;
                option.textContent = player;
                select.appendChild(option);
            });
            
            select.onchange = function() {
                const selectedPlayer = this.value;
                const resultDiv = document.getElementById('roleSwapResult');
                
                if (selectedPlayer && gameState.selectedForElimination) {
                    resultDiv.innerHTML = `
                        <div class="eliminated-role">
                            ${gameState.selectedForElimination}'s role will be swapped with ${selectedPlayer}
                        </div>
                    `;
                } else if (selectedPlayer) {
                    resultDiv.innerHTML = `
                        <div class="eliminated-role">
                            Select a player for elimination first to see role swap details
                        </div>
                    `;
                } else {
                    resultDiv.innerHTML = '';
                }
            };
        }

function goToNight() {
    gameState.silencedPlayers = [];
    gameState.trialPlayer = null;
    
    // ===== CAPTURE DAY ELIMINATION HISTORY FIRST =====
    if (!gameState.dayHistory) {
        gameState.dayHistory = [];
    }

    const dayEliminatedPlayers = [];
    let eliminationMethod = '';
    
    // Handle Day 1 bullet mechanics
    if (gameState.dayNumber === 1) {
        const selectedBullet = gameState.selectedBullet;
        eliminationMethod = selectedBullet ? `Bullet ${selectedBullet.replace('bullet', '')}` : 'No bullet selected';
        
        if (selectedBullet) {
            const matchingSquare = document.getElementById(selectedBullet + 'Square');
            const playerInSquare = matchingSquare ? matchingSquare.querySelector('.player-in-square') : null;
            
            if (playerInSquare) {
                const playerToEliminate = playerInSquare.dataset.player;
                dayEliminatedPlayers.push(playerToEliminate);
                gameState.eliminated.push(playerToEliminate);
            }
        }
    } else {
        // Day 2+ - store eliminated player
        eliminationMethod = 'Voting';
        if (gameState.selectedForElimination) {
            dayEliminatedPlayers.push(gameState.selectedForElimination);
            gameState.eliminated.push(gameState.selectedForElimination);
            
            // Check if any last move abilities are still available
            const hasAvailableAbilities = !gameState.lockAbilityUsed || 
                                         !gameState.additionalEliminationUsed || 
                                         !gameState.roleSwapUsed;
            
            if (hasAvailableAbilities) {
                // Before going to last move abilities, save day history
                gameState.dayHistory.push({
                    dayNumber: gameState.dayNumber,
                    eliminated: [...dayEliminatedPlayers],
                    method: eliminationMethod
                });
                
                // Go to last move abilities page instead
                setupSpecialAbilitiesPage();
                goToPage(8);
                return; // Stop here
            }
        }
    }

    // Save day history for this day
    gameState.dayHistory.push({
        dayNumber: gameState.dayNumber,
        eliminated: [...dayEliminatedPlayers],
        method: eliminationMethod
    });
    // ===== END OF DAY HISTORY CAPTURE =====
 
    
    // Check if Master of Disguise's selected player was eliminated during the day
    if (!gameState.masterOfDisguisePlayer) {
        gameState.masterOfDisguisePlayer = gameState.players.find(p => gameState.assignments[p] === 'Master of Disguise');
    }
    
    const modSelection = gameState.masterOfDisguiseSelection;
    const modPlayer = gameState.masterOfDisguisePlayer;
    
    if (
        modPlayer &&
        modSelection &&
        gameState.eliminated.includes(modSelection) &&
        gameState.assignments[modPlayer] === 'Master of Disguise' &&
        !gameState.masterOfDisguiseTransformed
    ) {
        const inheritedRole = gameState.assignments[modSelection];
        gameState.assignments[modPlayer] = inheritedRole;
        gameState.masterOfDisguiseTransformed = true;
        gameState.masterOfDisguiseNewRole = inheritedRole;
        delete gameState.masterOfDisguiseSelection;
        
        const farsiRole = farsiTranslations.roles[inheritedRole] || '';
	document.getElementById('modNewRole').innerHTML = `
 	   ${inheritedRole}
  	  ${farsiRole ? `<br><span style="font-size: 0.5em; color: #95a5a6;">(${farsiRole})</span>` : ''}
	`;
        goToPage(7);
        return;
    }
    
    if (checkWinCondition()) return;
    
    document.getElementById('nightTitle').innerHTML = `<span class="emoji-icon">🌙</span>Night ${gameState.nightNumber}`;
    goToPage(5);
}

function setupNightActions() {
    // Check for Master of Disguise transformation FIRST
    if (gameState.masterOfDisguiseTransformed && gameState.masterOfDisguiseNewRole) {
        const inheritedRole = gameState.masterOfDisguiseNewRole;
const farsiRole = farsiTranslations.roles[inheritedRole] || '';
document.getElementById('modNewRole').innerHTML = `
    ${inheritedRole}${farsiRole ? `<br><span style="font-size: 0.5em; color: #f1c40f; margin-top: 10px; display: block;">(${farsiRole})</span>` : ''}
`;
        goToPage(7);
        return;
    }

    const alivePlayers = gameState.players.filter(p => !gameState.eliminated.includes(p));
    const allPlayers = gameState.players;
    const aliveRoles = {};
    const allRoles = {};
    
    alivePlayers.forEach(player => {
        const role = gameState.assignments[player];
        if (!aliveRoles[role]) aliveRoles[role] = [];
        aliveRoles[role].push(player);
    });
    
    allPlayers.forEach(player => {
        const role = gameState.assignments[player];
        if (!allRoles[role]) allRoles[role] = [];
        allRoles[role].push(player);
    });
    
    console.log('All Roles:', allRoles);
    console.log('Alive Roles:', aliveRoles);
    
    createNightTabs(allRoles, aliveRoles);
    
    setTimeout(() => {
        showFirstTab();
    }, 50);
}

function continueToNightActions() {
    // Clear the transformation flags
    gameState.masterOfDisguiseTransformed = false;
    delete gameState.masterOfDisguiseNewRole;
 
    document.getElementById('nightTitle').innerHTML = `<span class="emoji-icon">🌙</span>Night ${gameState.nightNumber}`;
    

    goToPage(5);
    setupNightActions();
}

function createNightTab(roleName, isActive, isFirst) {
    const tab = document.createElement('button');
    tab.className = 'night-tab';
    tab.dataset.role = roleName;
    if (!isActive) tab.classList.add('eliminated');
    if (isFirst) tab.classList.add('active');
    
    const farsiName = farsiTranslations.nightTabs[roleName] || '';
    tab.innerHTML = `${roleName}${farsiName ? `<span class="farsi-subtitle">${farsiName}</span>` : ''}`;
    
    tab.onclick = () => switchNightTab(roleName);
    document.getElementById('nightTabs').appendChild(tab);
}

     function createNightTabs(allRoles, aliveRoles) {
    const tabsContainer = document.getElementById('nightTabs');
    const contentContainer = document.getElementById('nightTabsContent');
    
    tabsContainer.innerHTML = '';
    contentContainer.innerHTML = '';
    
    let firstTab = true;
    
    // Master of Disguise
    if (allRoles['Master of Disguise'] && allRoles['Master of Disguise'].length > 0) {
        if (gameState.nightNumber === 1 && !gameState.masterOfDisguiseTransformed) {
            const isActive = aliveRoles['Master of Disguise'] && aliveRoles['Master of Disguise'].length > 0;
            createNightTab('Master of Disguise', isActive, firstTab);
            createRoleTabContent('Master of Disguise', allRoles['Master of Disguise'], aliveRoles['Master of Disguise'] || [], isActive);
            firstTab = false;
        }
    }
    
    // Jailer
    if (allRoles['Jailer'] && allRoles['Jailer'].length > 0) {
        const isActive = aliveRoles['Jailer'] && aliveRoles['Jailer'].length > 0;
        createNightTab('Jailer', isActive, firstTab);
        createRoleTabContent('Jailer', allRoles['Jailer'], aliveRoles['Jailer'] || [], isActive);
        firstTab = false;
    }
    
    // Mafia (combined)
    const hasMafia = allRoles['Godfather - Mafia'] || allRoles['Executioner - Mafia'] || allRoles['Regular Mafia'];
    if (hasMafia) {
        const mafiaMembers = [];
        ['Godfather - Mafia', 'Executioner - Mafia', 'Regular Mafia'].forEach(mafiaRole => {
            if (aliveRoles[mafiaRole]) {
                mafiaMembers.push(...aliveRoles[mafiaRole]);
            }
        });
        createNightTab('Mafia', mafiaMembers.length > 0, firstTab);
        createMafiaTabContent(mafiaMembers, allRoles, aliveRoles);
        firstTab = false;
    }
    
    // Doctor
    if (allRoles['Doctor'] && allRoles['Doctor'].length > 0) {
        const isActive = aliveRoles['Doctor'] && aliveRoles['Doctor'].length > 0;
        createNightTab('Doctor', isActive, firstTab);
        createRoleTabContent('Doctor', allRoles['Doctor'], aliveRoles['Doctor'] || [], isActive);
        firstTab = false;
    }
    
    // Shooter
    if (allRoles['Shooter'] && allRoles['Shooter'].length > 0) {
        const isActive = aliveRoles['Shooter'] && aliveRoles['Shooter'].length > 0;
        createNightTab('Shooter', isActive, firstTab);
        createRoleTabContent('Shooter', allRoles['Shooter'], aliveRoles['Shooter'] || [], isActive);
        firstTab = false;
    }
    
    // Detective
    if (allRoles['Detective'] && allRoles['Detective'].length > 0) {
        const isActive = aliveRoles['Detective'] && aliveRoles['Detective'].length > 0;
        createNightTab('Detective', isActive, firstTab);
        createRoleTabContent('Detective', allRoles['Detective'], aliveRoles['Detective'] || [], isActive);
        firstTab = false;
    }
    
    // Devotee
    if (allRoles['Devotee'] && allRoles['Devotee'].length > 0) {
        const isActive = aliveRoles['Devotee'] && aliveRoles['Devotee'].length > 0;
        createNightTab('Devotee', isActive, firstTab);
        createRoleTabContent('Devotee', allRoles['Devotee'], aliveRoles['Devotee'] || [], isActive);
        firstTab = false;
    }
    
    // Psychiatrist
    if (allRoles['Psychiatrist'] && allRoles['Psychiatrist'].length > 0) {
        const isActive = aliveRoles['Psychiatrist'] && aliveRoles['Psychiatrist'].length > 0;
        createNightTab('Psychiatrist', isActive, firstTab);
        createRoleTabContent('Psychiatrist', allRoles['Psychiatrist'], aliveRoles['Psychiatrist'] || [], isActive);
        firstTab = false;
    }
}





        function createRoleTabContent(role, allPlayersWithRole, alivePlayersWithRole, isActive) {
    const contentContainer = document.getElementById('nightTabsContent');
    const content = document.createElement('div');
    content.className = 'night-tab-content';
    content.id = `tab-${role}`;

    // Show role name and player
    content.innerHTML = `<div class="night-role-display">${role}</div>`;

    if (alivePlayersWithRole.length > 0) {
        const player = alivePlayersWithRole[0];
        const isLocked = gameState.lockedPlayer === player;
	const isJailed = gameState.currentNightJailedPlayer === player;

        let playerDisplay = `<div class="player-name-display">${player}</div>`;

        if (gameState.modTransformation && gameState.modTransformation.role === role) {
            playerDisplay = `
                <div class="player-name-display">
                    <span style="text-decoration: line-through; color: #999;">${gameState.modTransformation.originalPlayer}</span><br>
                    <span style="color: #87ceeb; font-weight: bold;">${gameState.modTransformation.newPlayer}</span>
                </div>
            `;
        }

        content.innerHTML += playerDisplay;

        // Check if role is locked
        if (isLocked) {
            content.innerHTML += '<div class="jailed-message">Ability locked for this night</div>';
        } else if (isJailed) {
            content.innerHTML += '<div class="jailed-message">Player is jailed and cannot act</div>';
        }

        // Add special messages for roles with limited uses (Jailer, Shooter, Devotee, Psychiatrist)
        if (role === 'Jailer' && gameState.jailerUsesLeft === 0) {
            content.innerHTML += '<div class="jailed-message">No uses left</div>';
        } else if (role === 'Shooter' && gameState.shooterUsesLeft === 0) {
            content.innerHTML += '<div class="jailed-message">No uses left</div>';
        } else if (role === 'Devotee' && (typeof gameState.devoteeUsesLeft !== 'undefined') && gameState.devoteeUsesLeft === 0) {
            content.innerHTML += '<div class="jailed-message">No uses left</div>';
        } else if (role === 'Psychiatrist' && (typeof gameState.psychiatristUsesLeft !== 'undefined') && gameState.psychiatristUsesLeft === 0) {
            content.innerHTML += '<div class="jailed-message">No uses left</div>';
        }

        // Create player grid for target selection only if role is allowed to act
        // replicate the same checks as Jailer/Shooter for Devotee/Psychiatrist
        if (!isLocked &&
            !(role === 'Jailer' && gameState.jailerUsesLeft === 0) &&
            !(role === 'Shooter' && gameState.shooterUsesLeft === 0) &&
            !(role === 'Devotee' && (typeof gameState.devoteeUsesLeft !== 'undefined') && gameState.devoteeUsesLeft === 0) &&
            !(role === 'Psychiatrist' && (typeof gameState.psychiatristUsesLeft !== 'undefined') && gameState.psychiatristUsesLeft === 0) &&
            !(role === 'Master of Disguise' && (gameState.nightNumber > 1 || gameState.masterOfDisguiseTransformed))) {

            const playerGrid = document.createElement('div');
            playerGrid.className = 'night-player-grid';

          // Determine targets based on role
	let targets = gameState.players.filter(p => p !== player);
	// For Doctor, include themselves as a target option
	if (role === 'Doctor') {
    	targets.push(player); // Add the doctor back to the list
	}

            targets.forEach(target => {
                const targetDiv = document.createElement('div');
                targetDiv.className = 'night-player-item';
                targetDiv.dataset.player = target;
                targetDiv.dataset.role = role;

                // If eliminated, mark eliminated
                if (gameState.eliminated.includes(target)) {
                    targetDiv.classList.add('eliminated');
                } else {
                    // Respect usage / jail restrictions using shouldGreyOutPlayer
                    if (shouldGreyOutPlayer(target, role)) {
                        targetDiv.classList.add('greyed');
                        // provide tooltip explaining why
                        targetDiv.title = getUsageMessage(role) || 'Cannot target this player';
                        // do not attach onclick so the player cannot be selected
                    } else {
                        // attach click handler only if selectable
                        targetDiv.onclick = () => selectNightTarget(role, target);
                        targetDiv.title = getUsageMessage(role) || '';
                    }
                }

		const targetRole = gameState.assignments[target] || 'Unknown';
	const farsiRole = farsiTranslations.roles[targetRole] || '';
	targetDiv.innerHTML = `
    	<strong>${target}</strong><br>
   	 <span style="color: #95a5a6; font-size: 12px;">${targetRole}${farsiRole ? ` (${farsiRole})` : ''}</span>
	`;

                playerGrid.appendChild(targetDiv);
            });

            content.appendChild(playerGrid);
        }
    } else {
        // Role has no alive players
        const eliminatedPlayersWithRole = allPlayersWithRole.filter(p => gameState.eliminated.includes(p));
        if (eliminatedPlayersWithRole.length > 0) {
            eliminatedPlayersWithRole.forEach(player => {
                content.innerHTML += `<div class="eliminated-display">${player} - Eliminated</div>`;
            });
        } else if (role === 'Master of Disguise' && (gameState.nightNumber > 1 || gameState.masterOfDisguiseTransformed)) {
            content.innerHTML += `<div class="eliminated-display">No longer active</div>`;
        }
    }

    contentContainer.appendChild(content);
}
function createMafiaTabContent(mafiaMembers, allRoles, aliveRoles) {
    const contentContainer = document.getElementById('nightTabsContent');
    const content = document.createElement('div');
    content.className = 'night-tab-content';
    content.id = 'tab-Mafia';
    
    content.innerHTML = '<div class="night-role-display">Mafia</div>';
    
    // Show all mafia members - alive normally, eliminated with strike-through
    const allMafiaRoles = ['Godfather - Mafia', 'Executioner - Mafia', 'Regular Mafia'];
allMafiaRoles.forEach(role => {
    if (allRoles[role] && allRoles[role].length > 0) {
        const playersWithRole = allRoles[role];
        playersWithRole.forEach(member => {
            const isEliminated = gameState.eliminated.includes(member);
            const farsiRole = farsiTranslations.roles[role] || '';
            let memberDisplay = member;
            
            if (gameState.modTransformation && 
                gameState.modTransformation.role === role &&
                gameState.modTransformation.newPlayer === member) {
                memberDisplay = `
                    <span style="text-decoration: line-through; color: #999;">${gameState.modTransformation.originalPlayer}</span><br>
                    <span style="color: #87ceeb; font-weight: bold;">${member}</span>
                `;
            } else if (isEliminated) {
                memberDisplay = `<span style="text-decoration: line-through; color: #ec7063;">${member}</span>`;
            }
            
            content.innerHTML += `
                <div class="player-name-display">
                    ${memberDisplay}
                    <br><span style="color: #95a5a6; font-size: 12px;">${role}${farsiRole ? ` (${farsiRole})` : ''}</span>
                </div>
            `;
        });
    }
});
    
    if (mafiaMembers.length > 0) {
        // Check if any mafia member is locked or jailed
        const lockedMafia = mafiaMembers.find(m => m === gameState.lockedPlayer);
        const jailedMafia = mafiaMembers.find(m => m === gameState.currentNightJailedPlayer);
        const affectedMafia = lockedMafia || jailedMafia;
        
        const executionerAlive = aliveRoles['Executioner - Mafia'] && aliveRoles['Executioner - Mafia'].length > 0;
        const executionerAffected = executionerAlive && aliveRoles['Executioner - Mafia'].some(p => p === affectedMafia);
        
        const aliveMafiaRoles = [];
        if (aliveRoles['Godfather - Mafia']) aliveMafiaRoles.push(...aliveRoles['Godfather - Mafia']);
        if (aliveRoles['Executioner - Mafia']) aliveMafiaRoles.push(...aliveRoles['Executioner - Mafia']);
        if (aliveRoles['Regular Mafia']) aliveMafiaRoles.push(...aliveRoles['Regular Mafia']);
        
        const onlyExecutionerAlive = executionerAlive && aliveMafiaRoles.length === 1 && 
                                    aliveRoles['Executioner - Mafia'].length === 1;
        
        // Method selection buttons
        const methodDiv = document.createElement('div');
        methodDiv.className = 'method-buttons';
        
// Check if executioner is the ONLY unjailed/unlocked mafia member
const unjailedMafia = mafiaMembers.filter(m => m !== affectedMafia);
const onlyExecutionerUnjailed = unjailedMafia.length === 1 && 
                                 executionerAlive && 
                                 unjailedMafia[0] === aliveRoles['Executioner - Mafia'][0];

// Execution is disabled only if: no executioner OR executioner is affected
const executionDisabled = !executionerAlive || executionerAffected;

// Shot is disabled if: only executioner is unjailed (other mafia may exist but are jailed/locked)
const shotDisabled = onlyExecutionerUnjailed;

const shotSelected = onlyExecutionerUnjailed ? '' : 'selected';
const executionSelected = onlyExecutionerUnjailed ? 'selected' : '';

if (onlyExecutionerUnjailed) {
    selectedMafiaMethod = 'execution';
} else {
    selectedMafiaMethod = 'shot';
}

methodDiv.innerHTML = `
    <button class="method-button ${shotSelected}" id="shotButton" onclick="selectMafiaMethod('shot')" ${shotDisabled ? 'disabled' : ''}>Shot</button>
    <button class="method-button ${executionSelected}${executionDisabled ? ' disabled' : ''}" id="executionButton" onclick="selectMafiaMethod('execution')" ${executionDisabled ? 'disabled' : ''}>Execution</button>
`;
       content.appendChild(methodDiv);

// Show certainty buttons immediately if execution is auto-selected
if (onlyExecutionerUnjailed) {
    setTimeout(() => {
        const certaintyButtons = document.getElementById('certaintyButtons');
        if (certaintyButtons) {
            certaintyButtons.style.display = 'flex';
        }
    }, 10);
}
        
        // Certainty buttons
        const certaintyDiv = document.createElement('div');
        certaintyDiv.className = 'certainty-buttons';
        certaintyDiv.id = 'certaintyButtons';
        certaintyDiv.innerHTML = `
            <button class="certainty-button" id="trueButton" onclick="selectExecutionCertainty('true')">True</button>
            <button class="certainty-button" id="falseButton" onclick="selectExecutionCertainty('false')">False</button>
        `;
 		
        content.appendChild(certaintyDiv);
        
        // Create player grid for targets
        const playerGrid = document.createElement('div');
        playerGrid.className = 'night-player-grid';
        
        const nonMafiaPlayers = gameState.players.filter(p => 
            !mafiaMembers.includes(p) && !gameState.eliminated.includes(p)
        );
        
     nonMafiaPlayers.forEach(target => {
    const targetDiv = document.createElement('div');
    targetDiv.className = 'night-player-item';
    targetDiv.dataset.player = target;
    targetDiv.dataset.role = 'Mafia';
    
    targetDiv.onclick = () => selectNightTarget('Mafia', target);
    
    const targetRole = gameState.assignments[target] || 'Unknown';
    const farsiRole = farsiTranslations.roles[targetRole] || '';
    targetDiv.innerHTML = `
        <strong>${target}</strong><br>
        <span style="color: #95a5a6; font-size: 12px;">${targetRole}${farsiRole ? ` (${farsiRole})` : ''}</span>
    `;
    
    playerGrid.appendChild(targetDiv);
});
        
        content.appendChild(playerGrid);
    } else {
        content.innerHTML += `<div class="eliminated-display">All mafia members eliminated</div>`;
    }

    contentContainer.appendChild(content);
    
    // Apply disable effects after content is in DOM
    if (mafiaMembers.length > 0) {
        const lockedMafia = mafiaMembers.find(m => m === gameState.lockedPlayer);
        const jailedMafia = mafiaMembers.find(m => m === gameState.currentNightJailedPlayer);
        const affectedMafia = lockedMafia || jailedMafia;
        const affectedRole = affectedMafia ? gameState.assignments[affectedMafia] : null;
        
        if (affectedMafia) {
            const statusLabel = lockedMafia ? '(LOCKED)' : '(JAILED)';
            setTimeout(() => {
                applyMafiaDisableEffects(affectedMafia, affectedRole, statusLabel);
            }, 10);
        }
    }
}
               

        function switchNightTab(roleName) {
            // Remove active class from all tabs and contents
            document.querySelectorAll('.night-tab').forEach(tab => {
                tab.classList.remove('active');
            });
            document.querySelectorAll('.night-tab-content').forEach(content => {
                content.classList.remove('active');
            });
            
            // Add active class to selected tab and content
            const selectedTab = document.querySelector(`[data-role="${roleName}"]`);
            const selectedContent = document.getElementById(`tab-${roleName}`);
            
            if (selectedTab && selectedContent) {
                selectedTab.classList.add('active');
                selectedContent.classList.add('active');
            }
        }

        // Show first tab content by default
        function showFirstTab() {
            const firstTab = document.querySelector('.night-tab');
            const firstContent = document.querySelector('.night-tab-content');
            
            if (firstTab && firstContent) {
                firstTab.classList.add('active');
                firstContent.classList.add('active');
            }
        }
function selectNightTarget(role, target) {
    // For Jailer: if they already have a selection, clear the old one first
    if (role === 'Jailer' && gameState.nightSelections[role] && gameState.nightSelections[role] !== target) {
        clearJailEffects();
        // Clear the old selection visually
        document.querySelectorAll(`[data-role="${role}"]`).forEach(item => {
            if (item.classList.contains('night-player-item')) {
                item.classList.remove('selected');
            }
        });
    }
    
    // Clear previous selections for this role
    document.querySelectorAll(`[data-role="${role}"]`).forEach(item => {
        if (item.classList.contains('night-player-item')) {
            item.classList.remove('selected');
        }
    });
    
    // Toggle selection
    const targetDiv = document.querySelector(`[data-player="${target}"][data-role="${role}"]`);
    if (targetDiv) {
        if (gameState.nightSelections[role] === target) {
            // Deselect
            gameState.nightSelections[role] = null;
            targetDiv.classList.remove('selected');
            
            // If this was jailer, clear jail effects
            if (role === 'Jailer') {
                clearJailEffects();
            }
            
            // If this was detective, clear result display
            if (role === 'Detective') {
                clearDetectiveResult();
            }
        } else {
            // Select
            gameState.nightSelections[role] = target;
            targetDiv.classList.add('selected');
            
            // If this is jailer, apply jail effects immediately
            if (role === 'Jailer') {
                applyJailEffects(target);
            }
            
            // If this is detective, show result immediately
            if (role === 'Detective') {
                showDetectiveResult(target);
            }
        }
    }
}
        
function showDetectiveResult(target) {
    const targetRole = gameState.assignments[target];
    
    // Thumbs up for Executioner or Regular Mafia
    // Thumbs down for Godfather or any non-mafia player
    const isPositive = targetRole === 'Regular Mafia' || targetRole === 'Executioner - Mafia';
    const emoji = isPositive ? '👍' : '👎';
    const resultColor = isPositive ? '#27ae60' : '#e74c3c';
    
    // Find or create result display div
    let resultDiv = document.getElementById('detectiveResultDisplay');
    if (!resultDiv) {
        const detectiveContent = document.getElementById('tab-Detective');
        if (detectiveContent) {
            resultDiv = document.createElement('div');
            resultDiv.id = 'detectiveResultDisplay';
            resultDiv.style.cssText = `
                margin: 20px 0;
                padding: 30px;
                text-align: center;
                border-radius: 15px;
                font-size: 4em;
                animation: fadeIn 0.3s ease-in-out;
            `;
            // Insert after the role display
            const roleDisplay = detectiveContent.querySelector('.night-role-display');
            if (roleDisplay) {
                roleDisplay.after(resultDiv);
            } else {
                detectiveContent.insertBefore(resultDiv, detectiveContent.firstChild);
            }
        }
    }
    
    if (resultDiv) {
        resultDiv.style.backgroundColor = isPositive ? 'rgba(39, 174, 96, 0.2)' : 'rgba(231, 76, 60, 0.2)';
        resultDiv.style.border = `3px solid ${resultColor}`;
        resultDiv.style.boxShadow = `0 0 30px ${resultColor}40`;
        resultDiv.innerHTML = `
            <div style="font-size: 1em;">${emoji}</div>
            <div style="font-size: 0.3em; color: #ecf0f1; margin-top: 10px;">
                ${target}'s Investigation Result
            </div>
        `;
    }
}

function clearDetectiveResult() {
    const resultDiv = document.getElementById('detectiveResultDisplay');
    if (resultDiv) {
        resultDiv.remove();
    }
}



function applyJailEffects(jailedPlayer) {
    // Store the jailed player for this night
    gameState.currentNightJailedPlayer = jailedPlayer;
    
    // Get the role of the jailed player
    const jailedRole = gameState.assignments[jailedPlayer];
    
    // Handle mafia roles
    if (['Godfather - Mafia', 'Executioner - Mafia', 'Regular Mafia'].includes(jailedRole)) {
        applyMafiaDisableEffects(jailedPlayer, jailedRole, '(JAILED)');
    } else {
        // Non-mafia role - mark tab orange but keep it clickable
        const roleTab = document.querySelector(`[data-role="${jailedRole}"]`);
        const roleContent = document.getElementById(`tab-${jailedRole}`);
        
        if (roleTab) {
            roleTab.style.backgroundColor = '#ff0000';
            roleTab.style.borderColor = '#ff8c00';
        }
        
        if (roleContent) {
            // Add (JAILED) indicator to player name
            const playerDisplay = roleContent.querySelector('.player-name-display');
            if (playerDisplay && !playerDisplay.innerHTML.includes('(JAILED)')) {
                playerDisplay.innerHTML = playerDisplay.innerHTML.replace(
                    jailedPlayer,
                    `${jailedPlayer} <span style="color: #ff8c00; font-weight: bold; font-size: 12px;">(JAILED)</span>`
                );
            }
            
            // Disable all player items
            roleContent.querySelectorAll('.night-player-item').forEach(item => {
                item.style.pointerEvents = 'none';
                item.style.opacity = '0.5';
                item.style.cursor = 'not-allowed';
            });
        }
    }
}

// New helper function to apply mafia disable effects (used for both jail and lock)
function applyMafiaDisableEffects(affectedPlayer, affectedRole, statusLabel) {
    // Check if there's only one mafia member alive
    const alivePlayers = gameState.players.filter(p => !gameState.eliminated.includes(p));
    const aliveMafia = alivePlayers.filter(p => 
        ['Godfather - Mafia', 'Executioner - Mafia', 'Regular Mafia'].includes(gameState.assignments[p])
    );
    
    // Check if godfather is affected and only executioner remains
    const godfatherAffected = affectedRole === 'Godfather - Mafia';
    const onlyExecutionerRemains = aliveMafia.length === 2 && 
        aliveMafia.some(p => gameState.assignments[p] === 'Executioner - Mafia' && p !== affectedPlayer);
    
    // Mark mafia tab orange but keep it clickable
    const mafiaTab = document.querySelector('[data-role="Mafia"]');
    if (mafiaTab) {
        mafiaTab.style.backgroundColor = 'rgba(255, 165, 0, 0.6)';
        mafiaTab.style.borderColor = '#ff8c00';
    }
    
    // Disable selections ONLY if single mafia member (NOT when godfather eliminated with executioner alive)
    if (aliveMafia.length === 1) {
        const mafiaContent = document.getElementById('tab-Mafia');
        
        if (mafiaContent) {
            // Disable all player items in mafia content
            mafiaContent.querySelectorAll('.night-player-item').forEach(item => {
                item.style.pointerEvents = 'none';
                item.style.opacity = '0.5';
                item.style.cursor = 'not-allowed';
            });
            
            // Disable method buttons
            mafiaContent.querySelectorAll('.method-button').forEach(btn => {
                btn.disabled = true;
                btn.classList.remove('selected');
                btn.style.opacity = '0.5';
                btn.style.cursor = 'not-allowed';
            });
            
            // Hide certainty buttons
            const certaintyButtons = document.getElementById('certaintyButtons');
            if (certaintyButtons) {
                certaintyButtons.style.display = 'none';
            }
        }
    }
    
// Handle button states based on who is affected and who remains
    const mafiaContent = document.getElementById('tab-Mafia');
    if (mafiaContent) {
        // Check who can still act (not affected)
        const canActMafia = aliveMafia.filter(p => p !== affectedPlayer);
        const onlyExecutionerCanAct = canActMafia.length === 1 && 
                                       gameState.assignments[canActMafia[0]] === 'Executioner - Mafia';
        
        if (affectedRole === 'Executioner - Mafia' && aliveMafia.length > 1) {
            // Executioner is affected - disable execution
            const executionButton = mafiaContent.querySelector('#executionButton');
            if (executionButton) {
                executionButton.disabled = true;
                executionButton.classList.remove('selected');
                executionButton.style.opacity = '0.5';
                executionButton.style.cursor = 'not-allowed';
                
                // Auto-select shot button instead
                const shotButton = mafiaContent.querySelector('#shotButton');
                if (shotButton && !shotButton.disabled) {
                    shotButton.classList.add('selected');
                    selectedMafiaMethod = 'shot';
                }
                
                // Hide certainty buttons
                const certaintyButtons = document.getElementById('certaintyButtons');
                if (certaintyButtons) {
                    certaintyButtons.style.display = 'none';
                }
            }
        } else if (onlyExecutionerCanAct) {
            // Only Executioner can act - disable shot, enable execution
            const shotButton = mafiaContent.querySelector('#shotButton');
            const executionButton = mafiaContent.querySelector('#executionButton');
            
            if (shotButton) {
                shotButton.disabled = true;
                shotButton.classList.remove('selected');
                shotButton.style.opacity = '0.5';
                shotButton.style.cursor = 'not-allowed';
            }
            
            if (executionButton) {
                executionButton.disabled = false;
                executionButton.classList.add('selected');
                executionButton.style.opacity = '1';
                executionButton.style.cursor = 'pointer';
                selectedMafiaMethod = 'execution';
                
                // Show certainty buttons since execution is selected
                const certaintyButtons = document.getElementById('certaintyButtons');
                if (certaintyButtons) {
                    certaintyButtons.style.display = 'flex';
                }
            }
        }
    }
    // Update the mafia tab content to show status
    updateMafiaStatusLabel(affectedPlayer, statusLabel);
}
      function updateMafiaStatusLabel(affectedPlayer, statusLabel) {
    // Find and update the mafia tab content to show status
    const mafiaContent = document.getElementById('tab-Mafia');
    if (!mafiaContent) return;
    
    if (!affectedPlayer) return;
    
    // Update player name displays
    const playerDisplays = mafiaContent.querySelectorAll('.player-name-display');
    playerDisplays.forEach(display => {
        const text = display.textContent;
        // Remove any existing status markers first
        const cleanText = text.replace(/\s*\((JAILED|LOCKED)\)\s*/g, '').trim();
        
        if (cleanText === affectedPlayer || cleanText.includes(affectedPlayer)) {
            // Add status indicator
            if (!text.includes(statusLabel)) {
                display.innerHTML = display.innerHTML.replace(
                    affectedPlayer,
                    `${affectedPlayer} <span style="color: #ff8c00; font-weight: bold; font-size: 12px;">${statusLabel}</span>`
                );
            }
        }
    });
}
        
        function clearJailEffects() {
    // Clear the jailed player marker
    gameState.currentNightJailedPlayer = null;
    
    // Reset all tabs to normal appearance
    document.querySelectorAll('.night-tab').forEach(tab => {
        tab.style.backgroundColor = '';
        tab.style.borderColor = '';
        tab.style.pointerEvents = '';
        tab.style.opacity = '';
    });
    
    // Re-enable all content
    document.querySelectorAll('.night-tab-content').forEach(content => {
        content.querySelectorAll('.night-player-item').forEach(item => {
            item.style.pointerEvents = '';
            item.style.opacity = '';
            item.style.cursor = '';
        });
        
        content.querySelectorAll('.method-button').forEach(btn => {
            btn.disabled = false;
            btn.style.opacity = '';
            btn.style.cursor = '';
        });
        
        // Remove all (JAILED) indicators from ALL tabs (not just mafia)
        const playerDisplays = content.querySelectorAll('.player-name-display');
        playerDisplays.forEach(display => {
            display.innerHTML = display.innerHTML.replace(/\s*<span[^>]*>\(JAILED\)<\/span>\s*/g, '');
        });
    });
}


        // Global variables to track mafia selections
        let selectedMafiaMethod = 'shot';
        let selectedExecutionCertainty = null;

        function selectMafiaMethod(method) {
            selectedMafiaMethod = method;
            
            // Update button states
            document.getElementById('shotButton').classList.remove('selected');
            document.getElementById('executionButton').classList.remove('selected');
            document.getElementById(method + 'Button').classList.add('selected');
            
            // Show/hide certainty buttons
            const certaintyButtons = document.getElementById('certaintyButtons');
            if (method === 'execution') {
                certaintyButtons.style.display = 'flex';
            } else {
                certaintyButtons.style.display = 'none';
                selectedExecutionCertainty = null;
                // Reset certainty button states
                document.getElementById('trueButton').classList.remove('selected');
                document.getElementById('falseButton').classList.remove('selected');
            }
        }

        function selectExecutionCertainty(certainty) {
            selectedExecutionCertainty = certainty;
            
            // Update button states
            document.getElementById('trueButton').classList.remove('selected');
            document.getElementById('falseButton').classList.remove('selected');
            document.getElementById(certainty + 'Button').classList.add('selected');
        }












function setupSpecialAbilitiesPage() {
    const alivePlayers = gameState.players.filter(p => !gameState.eliminated.includes(p));
    const eliminatedPlayer = gameState.selectedForElimination;
    
    // Check if this player has already used a special ability
    if (eliminatedPlayer && gameState.playersWhoUsedSpecialAbility && 
        gameState.playersWhoUsedSpecialAbility.includes(eliminatedPlayer)) {
        
        const page8 = document.getElementById('page8');
        if (page8) {
            let warningDiv = document.getElementById('specialAbilityWarning');
            if (!warningDiv) {
                warningDiv = document.createElement('div');
                warningDiv.id = 'specialAbilityWarning';
                warningDiv.style.cssText = `
                    background: linear-gradient(135deg, rgba(231, 76, 60, 0.3), rgba(192, 57, 43, 0.3));
                    border: 3px solid #e74c3c;
                    border-radius: 15px;
                    padding: 30px;
                    margin: 20px 0;
                    text-align: center;
                    box-shadow: 0 10px 40px rgba(231, 76, 60, 0.4);
                `;
                warningDiv.innerHTML = `
                    <h2 style="color: #e74c3c; font-size: 1.8em; margin-bottom: 15px;">
                        Warning: Special Ability Already Used
                    </h2>
                    <p style="font-size: 1.3em; color: #ecf0f1;">
                        <strong>${eliminatedPlayer}</strong> has already used a Special Day Ability card and cannot use another one.
                    </p>
                `;
                
                const subtitle = page8.querySelector('.page-subtitle');
                if (subtitle) {
                    subtitle.after(warningDiv);
                }
            }
            
            // Hide tabs
            document.getElementById('specialAbilityTabs').style.display = 'none';
            document.getElementById('specialAbilityTabsContent').style.display = 'none';
        }
        
        return;
    }
    
    const existingWarning = document.getElementById('specialAbilityWarning');
    if (existingWarning) {
        existingWarning.remove();
    }
    
    // Show tabs
    document.getElementById('specialAbilityTabs').style.display = 'flex';
    document.getElementById('specialAbilityTabsContent').style.display = 'block';
    
    // Reset selections
    abilityUsedThisDay = null;
    selectedAdditionalEliminationChoice = null;
    selectedGuessRoleResult = null;
    selectedLockPlayer = null;
    selectedAdditionalEliminationPlayer = null;
    selectedGuessRolePlayerData = null;
    selectedMutePlayerData = null;
    selectedTrialPlayerData = null;
    
    createSpecialAbilityTabs(alivePlayers, eliminatedPlayer);
}

function createSpecialAbilityTabs(alivePlayers, eliminatedPlayer) {
    const tabsContainer = document.getElementById('specialAbilityTabs');
    const contentContainer = document.getElementById('specialAbilityTabsContent');
    
    tabsContainer.innerHTML = '';
    contentContainer.innerHTML = '';
    
    const abilities = [
        { id: 'lock', name: 'Handcuffs', used: gameState.lockAbilityUsed },
        { id: 'eliminate', name: 'Additional Elimination', used: gameState.additionalEliminationUsed },
        { id: 'guess', name: 'Guess the Role', used: gameState.guessRoleUsed, requiresEliminated: true },
        { id: 'reveal', name: 'Reveal Your Role', used: gameState.revealRoleUsed, requiresEliminated: true },
        { id: 'mute', name: 'Mute Player', used: gameState.mutePlayerUsed },
        { id: 'trial', name: 'Trial', used: gameState.trialUsed }
    ];
    
 abilities.forEach((ability, index) => {
    if (ability.requiresEliminated && !eliminatedPlayer) return;
    
    const tab = document.createElement('button');
    tab.className = 'special-ability-tab';
    tab.dataset.ability = ability.id;
    if (ability.used) tab.classList.add('used');
    // Remove auto-selection - user must click a tab
    
    const farsiName = farsiTranslations.specialAbilities[ability.name] || '';
    tab.innerHTML = `${ability.name}${ability.used ? ' (Used)' : ''}${farsiName ? `<span class="farsi-subtitle">${farsiName}</span>` : ''}`;
    
    tab.onclick = () => switchSpecialAbilityTab(ability.id);
    tabsContainer.appendChild(tab);
        
        const content = document.createElement('div');
        content.className = 'special-ability-tab-content';
        content.id = `tab-ability-${ability.id}`;
       // if (index === 0 || (ability.id === 'lock' && !ability.used)) content.classList.add('active');
        
        createAbilityContent(content, ability.id, alivePlayers, eliminatedPlayer, ability.used);
        contentContainer.appendChild(content);
    });
}

function createAbilityContent(container, abilityId, alivePlayers, eliminatedPlayer, isUsed) {
    if (isUsed) {
        container.style.opacity = '0.5';
        container.style.pointerEvents = 'none';
    }
    
    switch (abilityId) {
        case 'lock':
            container.innerHTML = `
                <h2>🔗</h2>
                <p style="color: #bdc3c7; margin-bottom: 15px;">Select a player to lock their ability for the next night.</p>
                <div id="lockPlayerGrid" class="night-player-grid"></div>
                <div id="lockPlayerResult"></div>
            `;
            if (!isUsed) {
                setTimeout(() => populatePlayerGrid('lockPlayerGrid', alivePlayers, selectLockPlayer), 10);
            }
            break;
            
        case 'eliminate':
            container.innerHTML = `
                <h2>💀 Additional Player Elimination (سلاخی)</h2>
                <p style="color: #bdc3c7; margin-bottom: 15px;">Select a player to potentially eliminate.</p>
                <div id="eliminatePlayerGrid" class="night-player-grid"></div>
                <div class="method-buttons" style="margin-top: 15px;">
                    <button class="method-button" id="additionalEliminationTrue" onclick="selectAdditionalElimination('true')">True (Eliminate)</button>
                    <button class="method-button" id="additionalEliminationFalse" onclick="selectAdditionalElimination('false')">False (Keep Alive)</button>
                </div>
                <div id="eliminatePlayerResult"></div>
            `;
            if (!isUsed) {
                setTimeout(() => populatePlayerGrid('eliminatePlayerGrid', alivePlayers, selectAdditionalEliminationPlayer), 10);
            }
            break;
            
        case 'guess':
            container.innerHTML = `
                <h2>🎯 Guess A Player's Role (ذهن زیبا)</h2>
                <p style="color: #bdc3c7; margin-bottom: 15px;">
                    <strong>${eliminatedPlayer}</strong> will guess a player's role. If correct, they return to the game!
                </p>
                <div id="guessPlayerGrid" class="night-player-grid"></div>
                <div class="method-buttons" style="margin-top: 15px;">
                    <button class="method-button" id="guessRoleTrue" onclick="selectGuessRoleResult('true')">Correct Guess</button>
                    <button class="method-button" id="guessRoleFalse" onclick="selectGuessRoleResult('false')">Wrong Guess</button>
                </div>
                <div id="guessPlayerResult"></div>
            `;
            if (!isUsed) {
                setTimeout(() => populatePlayerGrid('guessPlayerGrid', alivePlayers, (player) => {
                    const role = gameState.assignments[player];
                    selectGuessRolePlayer(player, role);
                }), 10);
            }
            break;
            
        case 'reveal':
            const role = eliminatedPlayer ? gameState.assignments[eliminatedPlayer] : '';
            container.innerHTML = `
                <h2>🎭 Reveal Your Role (افشای هویت)</h2>
                <p style="color: #bdc3c7; margin-bottom: 15px;">
                    <strong>${eliminatedPlayer}</strong> must reveal their role before leaving the game.
                </p>
                <div style="background: linear-gradient(135deg, rgba(241, 196, 15, 0.3), rgba(243, 156, 18, 0.3)); 
                            border: 2px solid #f1c40f; 
                            border-radius: 12px; 
                            padding: 20px; 
                            margin: 20px 0;
                            text-align: center;">
                    <div style="font-size: 1.8em; color: #f1c40f; font-weight: bold;">${role}</div>
                </div>
                <button onclick="confirmRevealRole()" style="width: 100%; max-width: 300px; margin: 10px auto; display: block;">
                    Confirm Role Revealed
                </button>
            `;
            break;
            
        case 'mute':
            container.innerHTML = `
                <h2>🔇 Mute A Player (سکوت)</h2>
                <p style="color: #bdc3c7; margin-bottom: 15px;">
                    The selected player will be muted and cannot speak during the next day phase.
                </p>
                <div id="mutePlayerGrid" class="night-player-grid"></div>
                <div id="mutePlayerResult"></div>
            `;
            if (!isUsed) {
                setTimeout(() => populatePlayerGrid('mutePlayerGrid', alivePlayers, selectMutePlayer), 10);
            }
            break;
            
        case 'trial':
            container.innerHTML = `
                <h2>⚖️ Trial (دفاعیه)</h2>
                <p style="color: #bdc3c7; margin-bottom: 15px;">
                    Select a player to put on trial during the next day phase.
                </p>
                <div id="trialPlayerGrid" class="night-player-grid"></div>
                <div id="trialPlayerResult"></div>
            `;
            if (!isUsed) {
                setTimeout(() => populatePlayerGrid('trialPlayerGrid', alivePlayers, selectTrialPlayer), 10);
            }
            break;
    }
}


function populatePlayerGrid(gridId, players, onClickHandler) {
    const grid = document.getElementById(gridId);
    if (!grid) return;
    
    grid.innerHTML = '';
    players.forEach(player => {
        const role = gameState.assignments[player];
        const farsiRole = farsiTranslations.roles[role] || '';
        const card = document.createElement('div');
        card.className = 'night-player-item';
        card.dataset.player = player;
        card.innerHTML = `
            <strong>${player}</strong><br>
            <span style="color: #95a5a6; font-size: 12px;">${role}${farsiRole ? ` (${farsiRole})` : ''}</span>
        `;
        card.onclick = () => onClickHandler(player);
        grid.appendChild(card);
    });
}

function switchSpecialAbilityTab(abilityId) {
    document.querySelectorAll('.special-ability-tab').forEach(tab => {
        tab.classList.remove('active');
    });
    document.querySelectorAll('.special-ability-tab-content').forEach(content => {
        content.classList.remove('active');
    });
    
    const selectedTab = document.querySelector(`[data-ability="${abilityId}"]`);
    const selectedContent = document.getElementById(`tab-ability-${abilityId}`);
    
    if (selectedTab && selectedContent) {
        selectedTab.classList.add('active');
        selectedContent.classList.add('active');
    }
}

// Clear selections from other abilities when a new one is selected
function clearOtherAbilitySelections(currentAbility) {
    const grids = {
        'lock': 'lockPlayerGrid',
        'eliminate': 'eliminatePlayerGrid',
        'guess': 'guessPlayerGrid',
        'mute': 'mutePlayerGrid',
        'trial': 'trialPlayerGrid'
    };
    
    Object.entries(grids).forEach(([ability, gridId]) => {
        if (ability !== currentAbility) {
            const grid = document.getElementById(gridId);
            if (grid) {
                grid.querySelectorAll('.night-player-item').forEach(card => {
                    card.classList.remove('selected');
                });
            }
        }
    });
    
    // Clear specific selections
    if (currentAbility !== 'lock') {
        selectedLockPlayer = null;
        const lockResult = document.getElementById('lockPlayerResult');
        if (lockResult) lockResult.innerHTML = '';
    }
    
    if (currentAbility !== 'eliminate') {
        selectedAdditionalEliminationPlayer = null;
        selectedAdditionalEliminationChoice = null;
        const eliminateResult = document.getElementById('eliminatePlayerResult');
        if (eliminateResult) eliminateResult.innerHTML = '';
        // Clear button selections
        const trueBtn = document.getElementById('additionalEliminationTrue');
        const falseBtn = document.getElementById('additionalEliminationFalse');
        if (trueBtn) trueBtn.classList.remove('selected');
        if (falseBtn) falseBtn.classList.remove('selected');
    }
    
    if (currentAbility !== 'guess') {
        selectedGuessRolePlayerData = null;
        selectedGuessRoleResult = null;
        const guessResult = document.getElementById('guessPlayerResult');
        if (guessResult) guessResult.innerHTML = '';
        // Clear button selections
        const trueBtn = document.getElementById('guessRoleTrue');
        const falseBtn = document.getElementById('guessRoleFalse');
        if (trueBtn) trueBtn.classList.remove('selected');
        if (falseBtn) falseBtn.classList.remove('selected');
    }
    
    if (currentAbility !== 'mute') {
        selectedMutePlayerData = null;
        const muteResult = document.getElementById('mutePlayerResult');
        if (muteResult) muteResult.innerHTML = '';
    }
    
    if (currentAbility !== 'trial') {
        selectedTrialPlayerData = null;
        const trialResult = document.getElementById('trialPlayerResult');
        if (trialResult) trialResult.innerHTML = '';
    }
}





function confirmSpecialAbilities() {
    // Check if any ability was actually used
    if (!abilityUsedThisDay) {
        // Allow continuing without using an ability
    }
    
    // Mark the ability as permanently used if it was selected
    if (abilityUsedThisDay === 'Lock' && selectedLockPlayer) {
        gameState.lockAbilityUsed = true;
    } else if (abilityUsedThisDay !== 'Lock') {
        gameState.lockedPlayer = null;
    }
    
    if (abilityUsedThisDay === 'AdditionalElimination' && selectedAdditionalEliminationPlayer && selectedAdditionalEliminationChoice === 'true') {
        gameState.eliminated.push(selectedAdditionalEliminationPlayer);
        gameState.additionalEliminationUsed = true;
    } else if (abilityUsedThisDay === 'AdditionalElimination' && selectedAdditionalEliminationPlayer && selectedAdditionalEliminationChoice !== null) {
        gameState.additionalEliminationUsed = true;
    }
    
    if (abilityUsedThisDay === 'GuessRole' && selectedGuessRolePlayerData && selectedGuessRoleResult === 'true') {
        const eliminatedIndex = gameState.eliminated.indexOf(gameState.selectedForElimination);
        if (eliminatedIndex > -1) {
            gameState.eliminated.splice(eliminatedIndex, 1);

            if (!gameState.playersWhoUsedSpecialAbility.includes(gameState.selectedForElimination)) {
                gameState.playersWhoUsedSpecialAbility.push(gameState.selectedForElimination);
            }
        }
        gameState.guessRoleUsed = true;
    } else if (abilityUsedThisDay === 'GuessRole' && selectedGuessRolePlayerData && selectedGuessRoleResult !== null) {
        gameState.guessRoleUsed = true;
    }
    
    if (abilityUsedThisDay === 'Trial' && selectedTrialPlayerData) {
        gameState.trialUsed = true;
    } else if (abilityUsedThisDay !== 'Trial') {
        gameState.trialPlayer = null;
    }
    
    if (abilityUsedThisDay === 'MutePlayer' && selectedMutePlayerData) {
        gameState.mutePlayerUsed = true;
    }
    
    // Mark that the eliminated player used an ability (to prevent reuse)
    if (abilityUsedThisDay && gameState.selectedForElimination) {
        if (!gameState.playersWhoUsedSpecialAbility) {
            gameState.playersWhoUsedSpecialAbility = [];
        }
        if (!gameState.playersWhoUsedSpecialAbility.includes(gameState.selectedForElimination)) {
            gameState.playersWhoUsedSpecialAbility.push(gameState.selectedForElimination);
        }
    }
    
    if (checkWinCondition()) return;
    
    if (!gameState.masterOfDisguisePlayer) {
        gameState.masterOfDisguisePlayer = gameState.players.find(p => gameState.assignments[p] === 'Master of Disguise');
    }
    
    const modSelection = gameState.masterOfDisguiseSelection;
    const modPlayer = gameState.masterOfDisguisePlayer;
    
    if (
        modPlayer &&
        modSelection &&
        gameState.eliminated.includes(modSelection) &&
        gameState.assignments[modPlayer] === 'Master of Disguise' &&
        !gameState.masterOfDisguiseTransformed
    ) {
        const inheritedRole = gameState.assignments[modSelection];
        gameState.assignments[modPlayer] = inheritedRole;
        gameState.masterOfDisguiseTransformed = true;
        gameState.masterOfDisguiseNewRole = inheritedRole;
        delete gameState.masterOfDisguiseSelection;
        
        const farsiRole = farsiTranslations.roles[inheritedRole] || '';
	document.getElementById('modNewRole').innerHTML = `
    	${inheritedRole}${farsiRole ? `<br><span style="font-size: 0.5em; color: #f1c40f; margin-top: 10px; display: block;">(${farsiRole})</span>` : ''}
	`;
        goToPage(7);
        return;
    }
    
    document.getElementById('nightTitle').innerHTML = `<span class="emoji-icon">🌙</span>Night ${gameState.nightNumber}`;
    goToPage(5);
}

function processNight() {
    const nightResults = [];
    const alivePlayers = gameState.players.filter(p => !gameState.eliminated.includes(p));
    const eliminatedThisNight = [];

    gameState.savedThisNight = [];
    gameState.silencedThisNight = [];

    // Initialize usage counters if not already set
    if (typeof gameState.jailerUsesLeft === 'undefined') {
        gameState.jailerUsesLeft = 2;
    }
    if (typeof gameState.shooterUsesLeft === 'undefined') {
        gameState.shooterUsesLeft = 2;
    }
    if (typeof gameState.devoteeUsesLeft === 'undefined') {
        gameState.devoteeUsesLeft = 2;
    }
    if (typeof gameState.psychiatristUsesLeft === 'undefined') {
        gameState.psychiatristUsesLeft = 2; // Psychiatrist can only use ability 2 times
    }
    if (typeof gameState.doctorSelfSaveUsed === 'undefined') {
        gameState.doctorSelfSaveUsed = false;
    }

    // Master of Disguise: store first-night selection only
    if (gameState.nightNumber === 1 && gameState.nightSelections['Master of Disguise']) {
        gameState.masterOfDisguiseSelection = gameState.nightSelections['Master of Disguise'];
        gameState.masterOfDisguisePlayer = alivePlayers.find(p => gameState.assignments[p] === 'Master of Disguise');
        nightResults.push(`Master of Disguise selected ${gameState.masterOfDisguiseSelection}.`);
    }

 


    // Track jailed player
    let jailedPlayer = null;

    // Jailer logic with usage tracking
    if (gameState.nightSelections['Jailer']) {
        if (gameState.jailerUsesLeft > 0) {
            jailedPlayer = gameState.nightSelections['Jailer'];
            gameState.jailerUsesLeft--;
            nightResults.push(`Jailer jailed ${jailedPlayer} for the night. (${gameState.jailerUsesLeft} uses remaining)`);
            gameState.jailedPlayer = jailedPlayer;
            
            if (gameState.jailerUsesLeft === 0) {
                nightResults.push(`Jailer has exhausted all 2 uses and can no longer jail players.`);
            }
        } else {
            nightResults.push(`Jailer attempted to jail but has no uses remaining.`);
        }
    } else {
        gameState.jailedPlayer = null;
    }

    // If mafia has only one member left and is jailed, disable mafia action
    const mafiaPlayers = alivePlayers.filter(p => ['Godfather - Mafia', 'Executioner - Mafia', 'Regular Mafia'].includes(gameState.assignments[p]));
    if (mafiaPlayers.length === 1 && mafiaPlayers[0] === jailedPlayer) {
        gameState.disableMafiaAction = true;
        nightResults.push(`Mafia (${jailedPlayer}) is jailed and cannot act.`);
    } else {
        gameState.disableMafiaAction = false;
    }

    // Doctor logic with self-save tracking
    if (gameState.nightSelections['Doctor'] && gameState.nightSelections['Doctor'] !== gameState.jailedPlayer) {
        const target = gameState.nightSelections['Doctor'];
        const doctorPlayer = alivePlayers.find(p => gameState.assignments[p] === 'Doctor');
        
        // Check if trying to self-save when already used
        if (target === doctorPlayer && gameState.doctorSelfSaveUsed) {
            nightResults.push(`Doctor attempted to self-save but has already used their one self-save.`);
        } else {
            gameState.savedThisNight.push(target);
            
            if (target === doctorPlayer) {
                gameState.doctorSelfSaveUsed = true;
                nightResults.push(`Doctor used their one-time self-save.`);
            } else {
                nightResults.push(`Doctor saved ${target}.`);
            }
        }
    }

    // Check if execution method requires confirmation
    if (gameState.nightSelections['Mafia'] && selectedMafiaMethod === 'execution' && selectedExecutionCertainty === null) {
        // Don't process the night until execution certainty is selected
        nightResults.push(`Waiting for execution certainty selection...`);
        gameState.nightResults = nightResults;
        showNightSummary();
        return; // Exit early until certainty is selected
    }

// Mafia logic
if (
    gameState.nightSelections['Mafia'] &&
    (!gameState.disableMafiaAction || gameState.nightSelections['Mafia'] !== jailedPlayer)
) {
    const target = gameState.nightSelections['Mafia'];
    const method = selectedMafiaMethod;
    let mafiaSuccess = false;

    if (method === 'execution') {
        const certainty = selectedExecutionCertainty;
        if (certainty === 'true') {
            // Execution bypasses doctor save
            mafiaSuccess = true;
            nightResults.push(`Mafia executed ${target} successfully. Doctor cannot save from execution.`);
        } else {
            nightResults.push(`Mafia execution of ${target} failed.`);
        }
    } else {
        const targetRole = gameState.assignments[target];

        // Ghost cannot be eliminated by mafia shot
        if (targetRole === 'Ghost') {
            nightResults.push(`Mafia shot ${target}, but Ghost cannot be eliminated by mafia attacks.`);
        } else if (targetRole === 'Godfather - Mafia' && gameState.godfatherShieldActive) {
            // Check if doctor saved the godfather
            if (gameState.savedThisNight.includes(target)) {
                nightResults.push(`Mafia shot ${target}. Godfather was saved by Doctor and shield remains intact.`);
            } else {
                gameState.godfatherShieldActive = false;
                mafiaSuccess = true;
                nightResults.push(`Mafia shot ${target}. Godfather's shield is broken and they are eliminated.`);
            }
        } else if (targetRole === 'Shooter' && gameState.shooterShieldActive) {
            // Check if doctor saved the shooter
            if (gameState.savedThisNight.includes(target)) {
                nightResults.push(`Mafia shot ${target}. Shooter was saved by Doctor and shield remains intact.`);
            } else {
                gameState.shooterShieldActive = false;
                nightResults.push(`Mafia shot ${target}. Shooter's shield absorbed the attack.`);
            }
        } else {
            if (!gameState.savedThisNight.includes(target)) {
                mafiaSuccess = true;
                nightResults.push(`Mafia shot ${target} successfully.`);
            } else {
                nightResults.push(`Mafia shot ${target}, but they were saved by Doctor.`);
            }
        }
    }

    if (mafiaSuccess) {
        eliminatedThisNight.push(target);
    }
}

// Shooter logic with usage tracking
if (gameState.nightSelections['Shooter']) {
    const shooterPlayer = alivePlayers.find(p => gameState.assignments[p] === 'Shooter');
    
    // Only skip if the SHOOTER themselves is jailed, not their target
    if (shooterPlayer === jailedPlayer) {
        nightResults.push(`Shooter is jailed and cannot act.`);
    } else if (gameState.shooterUsesLeft > 0) {
        const target = gameState.nightSelections['Shooter'];
        const targetRole = gameState.assignments[target];
        gameState.shooterUsesLeft--;

        let isMafia = ['Godfather - Mafia', 'Executioner - Mafia', 'Regular Mafia'].includes(targetRole);

        // MoD edge case: Check what MoD selected
        if (targetRole === 'Master of Disguise' && gameState.masterOfDisguiseSelection) {
            const modTargetRole = gameState.assignments[gameState.masterOfDisguiseSelection];
            // If MoD selected a mafia player, treat MoD as mafia
            if (['Godfather - Mafia', 'Executioner - Mafia', 'Regular Mafia'].includes(modTargetRole)) {
                isMafia = true;
            } else {
                // If MoD selected a town player, treat MoD as town
                isMafia = false;
            }
        }
        
        if (!isMafia) {
            if (shooterPlayer && !eliminatedThisNight.includes(shooterPlayer)) {
                eliminatedThisNight.push(shooterPlayer);
                nightResults.push(`Shooter shot non-mafia ${target} and is eliminated as penalty. (${gameState.shooterUsesLeft} uses remaining)`);
            }
        } else {
            if (targetRole === 'Godfather - Mafia' && gameState.godfatherShieldActive) {
                // Check if doctor saved the godfather
                if (gameState.savedThisNight.includes(target)) {
                    nightResults.push(`Shooter shot Godfather who was saved by Doctor. Shield remains intact. (${gameState.shooterUsesLeft} uses remaining)`);
                } else {
                    gameState.godfatherShieldActive = false;
                    nightResults.push(`Shooter shot Godfather. Shield is now broken. (${gameState.shooterUsesLeft} uses remaining)`);
                }
            } else {
                // Jailed players can still be shot - only doctor save protects
                if (!gameState.savedThisNight.includes(target)) {
                    eliminatedThisNight.push(target);
                    if (target === jailedPlayer) {
                        nightResults.push(`Shooter shot mafia ${target} (who was jailed) successfully. (${gameState.shooterUsesLeft} uses remaining)`);
                    } else {
                        nightResults.push(`Shooter shot mafia ${target} successfully. (${gameState.shooterUsesLeft} uses remaining)`);
                    }
                } else {
                    nightResults.push(`Shooter shot mafia ${target}, but they were saved by Doctor. (${gameState.shooterUsesLeft} uses remaining)`);
                }
            }
        }

        if (gameState.shooterUsesLeft === 0) {
            nightResults.push(`Shooter has exhausted all 2 uses and can no longer shoot.`);
        }
    } else {
        nightResults.push(`Shooter attempted to shoot but has no uses remaining.`);
    }
}

    // Detective logic with immediate result display
    if (gameState.nightSelections['Detective'] && gameState.nightSelections['Detective'] !== jailedPlayer) {
        const target = gameState.nightSelections['Detective'];
        const role = gameState.assignments[target];
        const isPositive = role === 'Regular Mafia' || role === 'Executioner - Mafia';
        const emoji = isPositive ? '👍' : '👎';
        
        nightResults.push(`Detective investigated ${target}. Result: ${emoji}`);
        
        // Show immediate result (this should also be handled in the UI when selection is made)
        gameState.lastDetectiveResult = { target, emoji };
    }

    // Devotee logic with usage tracking
    if (gameState.nightSelections['Devotee'] && gameState.nightSelections['Devotee'] !== jailedPlayer) {
        if (gameState.devoteeUsesLeft > 0) {
            const target = gameState.nightSelections['Devotee'];
            const targetRole = gameState.assignments[target];
            const isMafia = ['Godfather - Mafia', 'Executioner - Mafia', 'Regular Mafia'].includes(targetRole);
            const devoteePlayer = alivePlayers.find(p => gameState.assignments[p] === 'Devotee');
            gameState.devoteeUsesLeft--;

            if (isMafia) {
                if (devoteePlayer && !eliminatedThisNight.includes(devoteePlayer)) {
                    eliminatedThisNight.push(devoteePlayer);
                    nightResults.push(`Devotee woke up ${target} who is mafia. Devotee is eliminated. (${gameState.devoteeUsesLeft} uses remaining)`);
                }
            } else {
                nightResults.push(`Devotee woke up ${target} who is not mafia. Nothing happens. (${gameState.devoteeUsesLeft} uses remaining)`);
            }

            if (gameState.devoteeUsesLeft === 0) {
                nightResults.push(`Devotee has exhausted all 2 uses and can no longer wake up players.`);
            }
        } else {
            nightResults.push(`Devotee attempted to wake someone but has no uses remaining.`);
        }
    }

    // Psychiatrist logic with usage tracking
    if (gameState.nightSelections['Psychiatrist']) {
        if (gameState.nightSelections['Psychiatrist'] !== jailedPlayer) {
            if (gameState.psychiatristUsesLeft > 0) {
                const target = gameState.nightSelections['Psychiatrist'];
                gameState.silencedThisNight.push(target);
                gameState.psychiatristUsesLeft--;
                nightResults.push(`Psychiatrist treated ${target}. They will be silenced during the day. (${gameState.psychiatristUsesLeft} uses remaining)`);
                
                // Track silenced players for next day display
                if (!gameState.silencedPlayers) {
                    gameState.silencedPlayers = [];
                }
                gameState.silencedPlayers.push(target);

                if (gameState.psychiatristUsesLeft === 0) {
                    nightResults.push(`Psychiatrist has exhausted all 2 uses and can no longer treat players.`);
                }
            } else {
                nightResults.push(`Psychiatrist attempted to treat someone but has no uses remaining.`);
            }
        } else {
            nightResults.push(`Psychiatrist is jailed and cannot act.`);
        }
    }

    // Apply eliminations
    eliminatedThisNight.forEach(player => {
        if (!gameState.eliminated.includes(player)) {
            gameState.eliminated.push(player);
        }
    });


  
// --- MASTER OF DISGUISE: handle takeover if selected player was eliminated this night ---
// Ensure we know who the MoD player is (in case it wasn't stored earlier)
if (!gameState.masterOfDisguisePlayer) {
    gameState.masterOfDisguisePlayer = gameState.players.find(p => gameState.assignments[p] === 'Master of Disguise');
}

// Determine the selection (could be stored previously or present in this night's selections)
const modSelection = gameState.masterOfDisguiseSelection || gameState.nightSelections['Master of Disguise'];
const modPlayer = gameState.masterOfDisguisePlayer;

// If the selected target is now eliminated and MoD is still the Master of Disguise, set up the inheritance
if (
    modPlayer &&
    modSelection &&
    gameState.eliminated.includes(modSelection) &&
    gameState.assignments[modPlayer] === 'Master of Disguise'
) {
    const inheritedRole = gameState.assignments[modSelection];

    // assign the role immediately so UI/next-night behavior sees new role
    gameState.assignments[modPlayer] = inheritedRole;

    // flag for next-night popup (so popup appears at the start of the next night)
    gameState.masterOfDisguiseTransformed = true;
    gameState.masterOfDisguiseNewRole = inheritedRole;

    // clear selection to avoid reprocessing on later nights
    delete gameState.masterOfDisguiseSelection;

    // note it in the night's results so it appears in the summary as well
    nightResults.push(`Master of Disguise will become ${inheritedRole} starting next night.`);
}


// Reset selections
    gameState.lockedPlayer = null;
    gameState.nightSelections = {};
    gameState.currentNightJailedPlayer = null; // Clear current night jail
    gameState.jailedPlayer = null; // Clear any legacy jail variable
    selectedMafiaMethod = 'shot';
    selectedExecutionCertainty = null;

  // Store night results
    gameState.nightResults = nightResults;
    gameState.eliminatedThisNight = eliminatedThisNight;
    
    // Store in history
    if (!gameState.nightHistory) {
        gameState.nightHistory = [];
    }
    gameState.nightHistory.push({
        nightNumber: gameState.nightNumber,
        results: [...nightResults],
        eliminated: [...eliminatedThisNight],
        saved: [...(gameState.savedThisNight || [])],
        silenced: [...(gameState.silencedThisNight || [])]
    });


    // Apply eliminations
    eliminatedThisNight.forEach(player => {
        if (!gameState.eliminated.includes(player)) {
            gameState.eliminated.push(player);
        }
    });

   

    // Reset selections
    gameState.lockedPlayer = null;

    showNightSummary();
}

// Helper function to check if a role can still make selections
function canRoleAct(roleName) {
    switch (roleName) {
        case 'Jailer':
            return (gameState.jailerUsesLeft || 2) > 0;
        case 'Shooter':
            return (gameState.shooterUsesLeft || 2) > 0;
        case 'Devotee':
            return (gameState.devoteeUsesLeft || 2) > 0;
        case 'Psychiatrist':
            return (gameState.psychiatristUsesLeft || 2) > 0;
        case 'Doctor':
            return true; // Doctor can always act (self-save limit is per-player, not role)
        default:
            return true;
    }
}


// Helper function to check if a player should be greyed out for a specific role
function shouldGreyOutPlayer(playerName, roleName) {
    // Check if player is jailed (except for Jailer role)
    if (gameState.jailedPlayer === playerName && roleName !== 'Jailer') {
        return true;
    }

    // Check usage limits for specific roles
    switch (roleName) {
        case 'Jailer':
            return (gameState.jailerUsesLeft || 2) <= 0;
        case 'Shooter':
            return (gameState.shooterUsesLeft || 2) <= 0;
        case 'Devotee':
            return (gameState.devoteeUsesLeft || 2) <= 0;
        case 'Psychiatrist':
            return (gameState.psychiatristUsesLeft || 2) <= 0;
        case 'Doctor':
            // Grey out self-save option if already used
            const doctorPlayer = gameState.players.find(p => gameState.assignments[p] === 'Doctor');
            return playerName === doctorPlayer && gameState.doctorSelfSaveUsed;
        default:
            return false;
    }
}

// Helper function to get usage message for a role
function getUsageMessage(roleName) {
    switch (roleName) {
        case 'Jailer':
            return gameState.jailerUsesLeft <= 0 ? 'Jailer has exhausted all 2 uses.' : `Jailer has ${gameState.jailerUsesLeft} uses remaining.`;
        case 'Shooter':
            return gameState.shooterUsesLeft <= 0 ? 'Shooter has exhausted all 2 uses.' : `Shooter has ${gameState.shooterUsesLeft} uses remaining.`;
        case 'Devotee':
            return gameState.devoteeUsesLeft <= 0 ? 'Devotee has exhausted all 2 uses.' : `Devotee has ${gameState.devoteeUsesLeft} uses remaining.`;
        case 'Psychiatrist':
            return gameState.psychiatristUsesLeft <= 0 ? 'Psychiatrist has exhausted all 2 uses.' : `Psychiatrist has ${gameState.psychiatristUsesLeft} uses remaining.`;
        case 'Doctor':
            return gameState.doctorSelfSaveUsed ? 'Doctor has already used their one-time self-save.' : 'Doctor can still use their one-time self-save.';
        default:
            return '';
    }
}

// Helper function to get usage message for a role
function getUsageMessage(roleName) {
    switch (roleName) {
        case 'Jailer':
            return gameState.jailerUsesLeft <= 0 ? 'Jailer has exhausted all 2 uses.' : `Jailer has ${gameState.jailerUsesLeft} uses remaining.`;
        case 'Shooter':
            return gameState.shooterUsesLeft <= 0 ? 'Shooter has exhausted all 2 uses.' : `Shooter has ${gameState.shooterUsesLeft} uses remaining.`;
        case 'Devotee':
            return gameState.devoteeUsesLeft <= 0 ? 'Devotee has exhausted all 2 uses.' : `Devotee has ${gameState.devoteeUsesLeft} uses remaining.`;
        case 'Psychiatrist':
            return gameState.psychiatristUsesLeft <= 0 ? 'Psychiatrist has exhausted all 2 uses.' : `Psychiatrist has ${gameState.psychiatristUsesLeft} uses remaining.`;
        case 'Doctor':
            return gameState.doctorSelfSaveUsed ? 'Doctor has already used their one-time self-save.' : 'Doctor can still use their one-time self-save.';
        default:
            return '';
    }
}

// Helper function to get usage message for a role
function getUsageMessage(roleName) {
    switch (roleName) {
        case 'Jailer':
            return gameState.jailerUsesLeft <= 0 ? 'Jailer has exhausted all 2 uses.' : `Jailer has ${gameState.jailerUsesLeft} uses remaining.`;
        case 'Shooter':
            return gameState.shooterUsesLeft <= 0 ? 'Shooter has exhausted all 2 uses.' : `Shooter has ${gameState.shooterUsesLeft} uses remaining.`;
        case 'Devotee':
            return gameState.devoteeUsesLeft <= 0 ? 'Devotee has exhausted all 2 uses.' : `Devotee has ${gameState.devoteeUsesLeft} uses remaining.`;
        case 'Psychiatrist':
            return gameState.psychiatristUsesLeft <= 0 ? 'Psychiatrist has exhausted all 2 uses.' : `Psychiatrist has ${gameState.psychiatristUsesLeft} uses remaining.`;
        case 'Doctor':
            return gameState.doctorSelfSaveUsed ? 'Doctor has already used their one-time self-save.' : 'Doctor can still use their one-time self-save.';
        default:
            return '';
    }
}


function showNightSummary() {
    document.getElementById('summaryTitle').textContent = `Night ${gameState.nightNumber} Summary`;
    
    const resultsContainer = document.getElementById('nightResults');
    
    if (gameState.eliminatedThisNight && gameState.eliminatedThisNight.length > 0) {
        const eliminatedNames = gameState.eliminatedThisNight.join(' and ');
        resultsContainer.innerHTML = `<h2>${eliminatedNames} ${gameState.eliminatedThisNight.length === 1 ? 'has' : 'have'} been eliminated.</h2>`;
    } else {
        resultsContainer.innerHTML = '<h2>Nothing happened last night.</h2>';
    }
    
    // Add silenced players message if any
    if (gameState.silencedThisNight && gameState.silencedThisNight.length > 0) {
        const silencedNames = gameState.silencedThisNight.join(', ');
        resultsContainer.innerHTML += `
            <div style="background: linear-gradient(135deg, rgba(155, 89, 182, 0.3), rgba(142, 68, 173, 0.3)); 
                        border: 2px solid #9b59b6; 
                        border-radius: 15px; 
                        padding: 20px; 
                        margin: 20px 0;
                        box-shadow: 0 8px 25px rgba(155, 89, 182, 0.3);">
                <h3 style="color: #9b59b6; margin-top: 0;">🔇 Silenced for Next Day</h3>
                <p style="font-size: 1.2em; color: #ecf0f1;">${silencedNames} ${gameState.silencedThisNight.length === 1 ? 'is' : 'are'} silenced and cannot speak during the next day phase.</p>
            </div>
        `;
    }
    
    gameState.nightNumber++;
    goToPage(6);
    updateRevealButtonState();
}











function showNightHistory() {
    if ((!gameState.nightHistory || gameState.nightHistory.length === 0) && 
        (!gameState.dayHistory || gameState.dayHistory.length === 0)) {
        alert('No history available yet.');
        return;
    }
    
    // Store which page we came from
    gameState.previousHistoryPage = gameState.currentPage;

    const historyContent = document.getElementById('nightHistoryContent');
    historyContent.innerHTML = '';
    
    // Combine and sort day and night events chronologically
    const combinedHistory = [];
    
    // Add day events
    if (gameState.dayHistory) {
        gameState.dayHistory.forEach(day => {
            combinedHistory.push({
                type: 'day',
                number: day.dayNumber,
                data: day
            });
        });
    }
    
    // Add night events
    if (gameState.nightHistory) {
        gameState.nightHistory.forEach(night => {
            combinedHistory.push({
                type: 'night',
                number: night.nightNumber,
                data: night
            });
        });
    }
    
    // Sort chronologically (day 1, night 1, day 2, night 2, etc.)
    combinedHistory.sort((a, b) => {
        if (a.number !== b.number) {
            return a.number - b.number;
        }
        // If same number, day comes before night
        return a.type === 'day' ? -1 : 1;
    });
    
    // Display each event
    combinedHistory.forEach(event => {
        const eventDiv = document.createElement('div');
        
        if (event.type === 'day') {
            // Day elimination styling
            eventDiv.style.cssText = `
                background: linear-gradient(135deg, rgba(241, 196, 15, 0.3), rgba(243, 156, 18, 0.3));
                border: 2px solid #f1c40f;
                border-radius: 15px;
                padding: 20px;
                margin-bottom: 20px;
                box-shadow: 0 8px 25px rgba(241, 196, 15, 0.2);
            `;
            
            let content = `<h2 style="color: #f1c40f; margin-top: 0;">Day ${event.data.dayNumber} - Elimination</h2>`;
            
            if (event.data.eliminated && event.data.eliminated.length > 0) {
                const eliminatedPlayer = event.data.eliminated[0];
                const role = gameState.assignments[eliminatedPlayer];
                content += `<div style="background: rgba(231, 76, 60, 0.3); border: 1px solid #e74c3c; border-radius: 8px; padding: 15px; margin: 10px 0;">
                    <strong style="color: #e74c3c;">Eliminated by ${event.data.method}:</strong><br>
                    <span style="font-size: 1.2em;">${eliminatedPlayer} - ${role}</span>
                </div>`;
            } else {
                content += `<div style="background: rgba(39, 174, 96, 0.2); border: 1px solid #27ae60; border-radius: 8px; padding: 10px; margin: 10px 0;">
                    <strong style="color: #27ae60;">No elimination this day</strong>
                </div>`;
            }
            
            eventDiv.innerHTML = content;
            
        } else {
            // Night actions styling (existing code)
            eventDiv.style.cssText = `
                background: linear-gradient(135deg, rgba(52, 73, 94, 0.9), rgba(44, 62, 80, 0.9));
                border: 2px solid #3498db;
                border-radius: 15px;
                padding: 20px;
                margin-bottom: 20px;
                box-shadow: 0 8px 25px rgba(52, 152, 219, 0.2);
            `;
            
            let content = `<h2 style="color: #3498db; margin-top: 0;">Night ${event.data.nightNumber}</h2>`;
            
            // Show eliminations
            if (event.data.eliminated && event.data.eliminated.length > 0) {
                content += `<div style="background: rgba(231, 76, 60, 0.2); border: 1px solid #e74c3c; border-radius: 8px; padding: 10px; margin: 10px 0;">
                    <strong style="color: #e74c3c;">Eliminated:</strong> ${event.data.eliminated.join(', ')}
                </div>`;
            } else {
                content += `<div style="background: rgba(39, 174, 96, 0.2); border: 1px solid #27ae60; border-radius: 8px; padding: 10px; margin: 10px 0;">
                    <strong style="color: #27ae60;">No eliminations this night</strong>
                </div>`;
            }
            
            // Show saved players
            if (event.data.saved && event.data.saved.length > 0) {
                content += `<div style="background: rgba(39, 174, 96, 0.2); border: 1px solid #27ae60; border-radius: 8px; padding: 10px; margin: 10px 0;">
                    <strong style="color: #27ae60;">Saved by Doctor:</strong> ${event.data.saved.join(', ')}
                </div>`;
            }
            
            // Show silenced players
            if (event.data.silenced && event.data.silenced.length > 0) {
                content += `<div style="background: rgba(155, 89, 182, 0.2); border: 1px solid #9b59b6; border-radius: 8px; padding: 10px; margin: 10px 0;">
                    <strong style="color: #9b59b6;">Silenced:</strong> ${event.data.silenced.join(', ')}
                </div>`;
            }
            
            // Show detailed actions
            content += `<div style="margin-top: 15px;">
                <strong>Detailed Actions:</strong>
                <ul style="margin: 10px 0; padding-left: 20px;">`;
            
            event.data.results.forEach(result => {
                content += `<li style="margin: 5px 0; color: #ecf0f1;">${result}</li>`;
            });
            
            content += `</ul></div>`;
            
            eventDiv.innerHTML = content;
        }
        
        historyContent.appendChild(eventDiv);
    });
    
    goToPage(9);
    updateHistoryBackButton();
}

function updateHistoryBackButton() {
    const page9 = document.getElementById('page9');
    const navButtons = page9.querySelector('.nav-buttons');
    
    if (gameState.previousHistoryPage === 10) {
        // If came from Game Over page, go back there
        navButtons.innerHTML = '<button onclick="goToPage(10)">Back to Game Over</button>';
    } else if (gameState.previousHistoryPage === 4) {
        // If came from Day page, go back there
        navButtons.innerHTML = '<button onclick="goToPage(4)">Back to Day Elimination</button>';
    } else {
        // Otherwise go back to night summary
        navButtons.innerHTML = '<button onclick="goToPage(6)">Back to Current Night</button>';
    }
}


function revealEliminationCount() {
    if (typeof gameState.lastRevealNight === 'undefined') {
        gameState.lastRevealNight = -1;
    }

    // If no reveals left and last reveal was before this night, do NOT reveal again
    if (gameState.eliminationCountRevealsLeft <= 0 && gameState.lastRevealNight < gameState.nightNumber) {
        // Optionally update UI to "No More Game Stats"
        const btn = document.getElementById('revealBtn');
        if (btn) {
            btn.textContent = "No More Game Stats";
            btn.onclick = null;
            btn.classList.add('disabled-button');
        }
        return; // block further reveal
    }

    // If first reveal this night, consume one reveal count
    if (gameState.lastRevealNight !== gameState.nightNumber) {
        if (gameState.eliminationCountRevealsLeft > 0) {
            gameState.eliminationCountRevealsLeft--;
            gameState.lastRevealNight = gameState.nightNumber;
        }
    }

    gameState.eliminationCountRevealed = true;

    // Build eliminated roles summary
    const eliminatedRoles = {};
    gameState.eliminated.forEach(player => {
        const role = gameState.assignments[player];
        if (!eliminatedRoles[role]) eliminatedRoles[role] = 0;
        eliminatedRoles[role]++;
    });

    const eliminatedMafia = (eliminatedRoles['Godfather - Mafia'] || 0) +
                            (eliminatedRoles['Executioner - Mafia'] || 0) +
                            (eliminatedRoles['Regular Mafia'] || 0);

    const eliminatedNonMafia = gameState.eliminated.length - eliminatedMafia;

    const summaryDiv = document.getElementById('eliminationSummary');
    if (summaryDiv) {
        summaryDiv.style.display = 'block';
        summaryDiv.innerHTML = `
            <strong>Elimination Count (Night ${gameState.nightNumber})</strong><br>
            <span style="color:#95a5a6;">Total Eliminated:</span> ${gameState.eliminated.length}<br>
            <span style="color:#f1c40f;">Mafia Eliminated:</span> ${eliminatedMafia}<br>
            <span style="color:#41ab64;">Non-Mafia Eliminated:</span> ${eliminatedNonMafia}<br>
            <em>Reveals Left:</em> ${gameState.eliminationCountRevealsLeft}
        `;
    }

    // Update button to hide state
    const btn = document.getElementById('revealBtn');
    if (btn) {
        btn.textContent = "Hide Elimination Count";
        btn.onclick = hideEliminationCount;
        btn.classList.remove('disabled-button');
    }
}

function hideEliminationCount() {
    gameState.eliminationCountRevealed = false;

    const summaryDiv = document.getElementById('eliminationSummary');
    if (summaryDiv) {
        summaryDiv.style.display = 'none';
    }

    const btn = document.getElementById('revealBtn');
    if (btn) {
        // Disable button only if no reveals left and it's the night after the last reveal
        if (gameState.eliminationCountRevealsLeft <= 0 && gameState.nightNumber > gameState.lastRevealNight) {
            btn.textContent = "No More Game Stats";
            btn.onclick = null;
            btn.classList.add('disabled-button');
        } else {
            btn.textContent = "Reveal Elimination Count";
            btn.onclick = revealEliminationCount;
            btn.classList.remove('disabled-button');
        }
    }
}


function updateRevealButtonState() {
    const btn = document.getElementById('revealBtn');
    if (!btn) return;

    if (typeof gameState.lastRevealNight === 'undefined') {
        gameState.lastRevealNight = -1;
    }

    const revealsExhausted = gameState.eliminationCountRevealsLeft <= 0;
    const newNightSinceLastReveal = gameState.nightNumber > gameState.lastRevealNight;

    if (revealsExhausted && newNightSinceLastReveal) {
        btn.textContent = "No More Game Stats";
        btn.onclick = null;
        btn.classList.add('disabled-button');
    } else if (gameState.eliminationCountRevealed) {
        btn.textContent = "Hide Elimination Count";
        btn.onclick = hideEliminationCount;
        btn.classList.remove('disabled-button');
    } else {
        btn.textContent = "Reveal Elimination Count";
        btn.onclick = revealEliminationCount;
        btn.classList.remove('disabled-button');
    }
}






        function goToNextDay() {
            // ✅ Check win condition FIRST before proceeding to next day
   	 if (checkWinCondition()) return;
            gameState.dayNumber++;
 	
            document.getElementById('dayTitle').innerHTML = `<span class="emoji-icon">☀️</span>Day ${gameState.dayNumber} - Elimination`;
            
            gameState.selectedForElimination = null;
            document.getElementById('dayEliminatedRole').innerHTML = '';
            
            // Reset bullet selection for Day 1
            gameState.selectedBullet = null;
            document.getElementById('bullet1Button').classList.remove('selected');
            document.getElementById('bullet2Button').classList.remove('selected');
            
            const dropdowns = ['lockAbilitySelect', 'additionalEliminationSelect', 'roleSwapSelect'];
            dropdowns.forEach(id => {
                const element = document.getElementById(id);
                if (element) element.value = '';
            });
            
            const resultDivs = ['lockedPlayer', 'additionalEliminatedPlayer', 'roleSwapResult'];
            resultDivs.forEach(id => {
                const element = document.getElementById(id);
                if (element) element.innerHTML = '';
            });

   
            setupDayElimination();
            goToPage(4);
	    
        }

	 let rolesHidden = false;

	function toggleAllRoles() {
   	 rolesHidden = !rolesHidden;
   	 const day1Grid = document.getElementById('day1PlayersGrid');
   	 const day2Grid = document.getElementById('day2PlusPlayersGrid');
    	const btn = document.getElementById('toggleRolesBtn');

    	// Pick the grid that is currently visible
    	const activeGrid = (day1Grid && day1Grid.offsetParent !== null) ? day1Grid : day2Grid;
   	 if (!activeGrid) return;

  	  Array.from(activeGrid.children).forEach(playerDiv => {
        const roleSpan = playerDiv.querySelector('span');
        if (!roleSpan) return;

        if (rolesHidden) {
            playerDiv.dataset.originalRole = roleSpan.textContent;
            roleSpan.textContent = 'Hidden';
        } else {
            roleSpan.textContent = playerDiv.dataset.originalRole || 'No role';
        }
  	  });

    	btn.textContent = rolesHidden ? 'Show Roles' : 'Hide Roles';
	}



        // Initialize when page loads
        document.addEventListener('DOMContentLoaded', function() {
            console.log("DOM loaded, initializing...");
            initializeRoleSelection();
            updateGameStatsHeader();
            
            // Show first tab content by default when on night page
            setTimeout(() => {
                if (gameState.currentPage === 5) {
                    showFirstTab();
                }
            }, 100);
        });

        // Backup initialization
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', initializeRoleSelection);
        } else {
            initializeRoleSelection();
            updateGameStatsHeader();
        }



// Track which ability was used this day
let abilityUsedThisDay = null;

// Special Abilities Tracking
let selectedAdditionalEliminationChoice = null;
let selectedGuessRoleResult = null;

function disableOtherAbilities(usedAbility) {
    const abilities = [
        { name: 'Lock', sectionId: 'page8LockAbilitySection', selectId: 'page8LockAbilitySelect' },
        { name: 'AdditionalElimination', sectionId: 'page8AdditionalEliminationSection', selectId: 'page8AdditionalEliminationSelect' },
        { name: 'GuessRole', sectionId: 'page8GuessRoleSection', selectId: 'page8GuessRolePlayerSelect' },
        { name: 'RevealRole', sectionId: 'page8RevealRoleSection', selectId: null },
        { name: 'MutePlayer', sectionId: 'page8MutePlayerSection', selectId: 'page8MutePlayerSelect' },
        { name: 'Trial', sectionId: 'page8TrialSection', selectId: 'page8TrialSelect' }
    ];
    
    abilities.forEach(ability => {
        if (ability.name !== usedAbility) {
            const section = document.getElementById(ability.sectionId);
            if (section) {
                section.style.opacity = '0.5';
                section.style.pointerEvents = 'none';
                
                // Disable all inputs in that section
                const inputs = section.querySelectorAll('select, button');
                inputs.forEach(input => {
                    input.disabled = true;
                });
                
                // Specifically disable the select dropdown if it exists
                if (ability.selectId) {
                    const select = document.getElementById(ability.selectId);
                    if (select) {
                        select.disabled = true;
                    }
                }
            }
        }
    });
}


// Helper variables for player card selections
let selectedLockPlayer = null;
let selectedAdditionalEliminationPlayer = null;
let selectedGuessRolePlayerData = null;
let selectedMutePlayerData = null;
let selectedTrialPlayerData = null;






function selectLockPlayer(player) {
    // Toggle: if clicking the same player, unselect
    if (selectedLockPlayer === player) {
        selectedLockPlayer = null;
        abilityUsedThisDay = null;
        gameState.lockedPlayer = null;
        
        document.querySelectorAll('#lockPlayerGrid .night-player-item').forEach(card => {
            card.classList.remove('selected');
        });
        
        document.getElementById('lockPlayerResult').innerHTML = '';
        return;
    }
    
    clearOtherAbilitySelections('lock');
    selectedLockPlayer = player;
    abilityUsedThisDay = 'Lock';
    gameState.lockedPlayer = player;
    
    document.querySelectorAll('#lockPlayerGrid .night-player-item').forEach(card => {
        card.classList.remove('selected');
    });
    
    const selectedCard = document.querySelector(`#lockPlayerGrid [data-player="${player}"]`);
    if (selectedCard) {
        selectedCard.classList.add('selected');
    }
    
    document.getElementById('lockPlayerResult').innerHTML = `
        <div class="eliminated-role">
            ${player}'s ability will be locked for the next night
        </div>
    `;
}





function selectAdditionalEliminationPlayer(player) {
    // Toggle: if clicking the same player, unselect
    if (selectedAdditionalEliminationPlayer === player) {
        selectedAdditionalEliminationPlayer = null;
        selectedAdditionalEliminationChoice = null;
        abilityUsedThisDay = null;
        
        document.querySelectorAll('#eliminatePlayerGrid .night-player-item').forEach(card => {
            card.classList.remove('selected');
        });
        
        document.getElementById('additionalEliminationTrue').classList.remove('selected');
        document.getElementById('additionalEliminationFalse').classList.remove('selected');
        document.getElementById('eliminatePlayerResult').innerHTML = '';
        return;
    }
    
    clearOtherAbilitySelections('eliminate');
    selectedAdditionalEliminationPlayer = player;
    
    document.querySelectorAll('#eliminatePlayerGrid .night-player-item').forEach(card => {
        card.classList.remove('selected');
    });
    
    const selectedCard = document.querySelector(`#eliminatePlayerGrid [data-player="${player}"]`);
    if (selectedCard) {
        selectedCard.classList.add('selected');
    }
    
    // Reset choice buttons
    selectedAdditionalEliminationChoice = null;
    document.getElementById('additionalEliminationTrue').classList.remove('selected');
    document.getElementById('additionalEliminationFalse').classList.remove('selected');
    document.getElementById('eliminatePlayerResult').innerHTML = '';
}


function selectGuessRolePlayer(player, role) {
    // Toggle: if clicking the same player, unselect
    if (selectedGuessRolePlayerData && selectedGuessRolePlayerData.player === player) {
        selectedGuessRolePlayerData = null;
        selectedGuessRoleResult = null;
        abilityUsedThisDay = null;
        
        document.querySelectorAll('#guessPlayerGrid .night-player-item').forEach(card => {
            card.classList.remove('selected');
        });
        
        document.getElementById('guessRoleTrue').classList.remove('selected');
        document.getElementById('guessRoleFalse').classList.remove('selected');
        document.getElementById('guessPlayerResult').innerHTML = '';
        return;
    }
    
    clearOtherAbilitySelections('guess');
    selectedGuessRolePlayerData = { player, role };
    
    document.querySelectorAll('#guessPlayerGrid .night-player-item').forEach(card => {
        card.classList.remove('selected');
    });
    
    const selectedCard = document.querySelector(`#guessPlayerGrid [data-player="${player}"]`);
    if (selectedCard) {
        selectedCard.classList.add('selected');
    }
    
    // Reset result buttons
    selectedGuessRoleResult = null;
    document.getElementById('guessRoleTrue').classList.remove('selected');
    document.getElementById('guessRoleFalse').classList.remove('selected');
    document.getElementById('guessPlayerResult').innerHTML = '';
}


function selectMutePlayer(player) {
    // Toggle: if clicking the same player, unselect
    if (selectedMutePlayerData === player) {
        selectedMutePlayerData = null;
        abilityUsedThisDay = null;
        
        // Remove from silenced players array
        if (gameState.silencedPlayers) {
            const index = gameState.silencedPlayers.indexOf(player);
            if (index > -1) {
                gameState.silencedPlayers.splice(index, 1);
            }
        }
        
        document.querySelectorAll('#mutePlayerGrid .night-player-item').forEach(card => {
            card.classList.remove('selected');
        });
        
        document.getElementById('mutePlayerResult').innerHTML = '';
        return;
    }
    
    clearOtherAbilitySelections('mute');
    selectedMutePlayerData = player;
    abilityUsedThisDay = 'MutePlayer';
    
    if (!gameState.silencedPlayers) {
        gameState.silencedPlayers = [];
    }
    if (!gameState.silencedPlayers.includes(player)) {
        gameState.silencedPlayers.push(player);
    }
    
    document.querySelectorAll('#mutePlayerGrid .night-player-item').forEach(card => {
        card.classList.remove('selected');
    });
    
    const selectedCard = document.querySelector(`#mutePlayerGrid [data-player="${player}"]`);
    if (selectedCard) {
        selectedCard.classList.add('selected');
    }
    
    document.getElementById('mutePlayerResult').innerHTML = `
        <div class="eliminated-role">
            ${player} will be muted during the next day phase
        </div>
    `;
}








function selectTrialPlayer(player) {
    // Toggle: if clicking the same player, unselect
    if (selectedTrialPlayerData === player) {
        selectedTrialPlayerData = null;
        abilityUsedThisDay = null;
        gameState.trialPlayer = null;
        
        document.querySelectorAll('#trialPlayerGrid .night-player-item').forEach(card => {
            card.classList.remove('selected');
        });
        
        document.getElementById('trialPlayerResult').innerHTML = '';
        return;
    }
    
    clearOtherAbilitySelections('trial');
    selectedTrialPlayerData = player;
    abilityUsedThisDay = 'Trial';
    gameState.trialPlayer = player;
    
    document.querySelectorAll('#trialPlayerGrid .night-player-item').forEach(card => {
        card.classList.remove('selected');
    });
    
    const selectedCard = document.querySelector(`#trialPlayerGrid [data-player="${player}"]`);
    if (selectedCard) {
        selectedCard.classList.add('selected');
    }
    
    document.getElementById('trialPlayerResult').innerHTML = `
        <div class="eliminated-role">
            ${player} will be put on trial during the next day phase
        </div>
    `;
}


function confirmLockPlayer() {
    if (selectedLockPlayer) {
        abilityUsedThisDay = 'Lock';
        gameState.lockedPlayer = selectedLockPlayer;
        disableOtherAbilities('Lock');
        
        const resultDiv = document.getElementById('page8LockedPlayer');
        resultDiv.innerHTML = `
            <div class="eliminated-role">
                ${selectedLockPlayer}'s ability will be locked for the next night
            </div>
        `;
        
        document.getElementById('page8LockConfirmBtn').disabled = true;
        document.getElementById('page8LockConfirmBtn').textContent = 'Confirmed';
        
        document.querySelectorAll('#page8LockPlayerGrid .night-player-item').forEach(card => {
            card.style.pointerEvents = 'none';
            card.style.opacity = '0.7';
        });
    }
}

function confirmMutePlayer() {
    if (selectedMutePlayerData) {
        abilityUsedThisDay = 'MutePlayer';
        
        if (!gameState.silencedPlayers) {
            gameState.silencedPlayers = [];
        }
        gameState.silencedPlayers.push(selectedMutePlayerData);
        gameState.mutePlayerUsed = true;
        
        disableOtherAbilities('MutePlayer');
        
        const resultDiv = document.getElementById('page8MutedPlayer');
        resultDiv.innerHTML = `
            <div class="eliminated-role">
                ${selectedMutePlayerData} will be muted during the next day phase
            </div>
        `;
        
        document.getElementById('page8MuteConfirmBtn').disabled = true;
        document.getElementById('page8MuteConfirmBtn').textContent = 'Confirmed';
        
        document.querySelectorAll('#page8MutePlayerGrid .night-player-item').forEach(card => {
            card.style.pointerEvents = 'none';
            card.style.opacity = '0.7';
        });
    }
}

function confirmTrial() {
    if (selectedTrialPlayerData) {
        abilityUsedThisDay = 'Trial';
        gameState.trialPlayer = selectedTrialPlayerData;
        disableOtherAbilities('Trial');
        
        const resultDiv = document.getElementById('page8TrialResult');
        resultDiv.innerHTML = `
            <div class="eliminated-role">
                ${selectedTrialPlayerData} will be put on trial during the next day phase
            </div>
        `;
        
        document.getElementById('page8TrialConfirmBtn').disabled = true;
        document.getElementById('page8TrialConfirmBtn').textContent = 'Confirmed';
        
        document.querySelectorAll('#page8TrialGrid .night-player-item').forEach(card => {
            card.style.pointerEvents = 'none';
            card.style.opacity = '0.7';
        });
    }
}
function selectAdditionalElimination(choice) {
    if (!selectedAdditionalEliminationPlayer) {
        // Silently return instead of alert
        return;
    }
    
    // Toggle: if clicking the same button, unselect it
    if (selectedAdditionalEliminationChoice === choice) {
        selectedAdditionalEliminationChoice = null;
        document.getElementById('additionalEliminationTrue').classList.remove('selected');
        document.getElementById('additionalEliminationFalse').classList.remove('selected');
        document.getElementById('eliminatePlayerResult').innerHTML = '';
        return;
    }
    
    selectedAdditionalEliminationChoice = choice;
    abilityUsedThisDay = 'AdditionalElimination';
    
    document.getElementById('additionalEliminationTrue').classList.remove('selected');
    document.getElementById('additionalEliminationFalse').classList.remove('selected');
    document.getElementById(choice === 'true' ? 'additionalEliminationTrue' : 'additionalEliminationFalse').classList.add('selected');
    
    const resultDiv = document.getElementById('eliminatePlayerResult');
    
    if (selectedAdditionalEliminationPlayer && choice) {
        const action = choice === 'true' ? 'will be eliminated' : 'will stay alive';
        resultDiv.innerHTML = `
            <div class="eliminated-role" style="margin-top: 15px;">
                ${selectedAdditionalEliminationPlayer} ${action}
            </div>
        `;
    } else {
        resultDiv.innerHTML = '';
    }
}

function selectGuessRoleResult(result) {
    if (!selectedGuessRolePlayerData) {
        // Silently return instead of alert
        return;
    }
    
    // Toggle: if clicking the same button, unselect it
    if (selectedGuessRoleResult === result) {
        selectedGuessRoleResult = null;
        document.getElementById('guessRoleTrue').classList.remove('selected');
        document.getElementById('guessRoleFalse').classList.remove('selected');
        document.getElementById('guessPlayerResult').innerHTML = '';
        return;
    }
    
    selectedGuessRoleResult = result;
    abilityUsedThisDay = 'GuessRole';
    
    document.getElementById('guessRoleTrue').classList.remove('selected');
    document.getElementById('guessRoleFalse').classList.remove('selected');
    document.getElementById(result === 'true' ? 'guessRoleTrue' : 'guessRoleFalse').classList.add('selected');
    
    const eliminatedPlayer = gameState.selectedForElimination;
    const resultDiv = document.getElementById('guessPlayerResult');
    
    if (selectedGuessRolePlayerData && result) {
        const { player, role } = selectedGuessRolePlayerData;
        
        if (result === 'true') {
            resultDiv.innerHTML = `
                <div class="eliminated-role" style="margin-top: 15px; background: linear-gradient(135deg, rgba(39, 174, 96, 0.3), rgba(30, 132, 73, 0.3)); border-color: #27ae60;">
                    ${eliminatedPlayer} guessed correctly! They will return to the game.<br>
                    ${player} stays in the game.
                </div>
            `;
        } else {
            resultDiv.innerHTML = `
                <div class="eliminated-role" style="margin-top: 15px;">
                    ${eliminatedPlayer} guessed incorrectly and remains eliminated.
                </div>
            `;
        }
    } else {
        resultDiv.innerHTML = '';
    }
}
function confirmRevealRole() {
    // Toggle behavior
    if (abilityUsedThisDay === 'RevealRole') {
        // Unselect
        abilityUsedThisDay = null;
        gameState.revealRoleUsed = false;
        
        const revealContent = document.getElementById('tab-ability-reveal');
        if (revealContent) {
            revealContent.style.opacity = '1';
            revealContent.style.pointerEvents = 'auto';
            
            const btn = revealContent.querySelector('button');
            if (btn) {
                btn.disabled = false;
                btn.textContent = 'Confirm Role Revealed';
            }
        }
    } else {
        // Select
        abilityUsedThisDay = 'RevealRole';
        gameState.revealRoleUsed = true;
        
        const revealContent = document.getElementById('tab-ability-reveal');
        if (revealContent) {
            revealContent.style.opacity = '0.5';
            revealContent.style.pointerEvents = 'none';
            
            const btn = revealContent.querySelector('button');
            if (btn) {
                btn.disabled = true;
                btn.textContent = 'Role Revealed';
            }
        }
    }
}

function showGameOver(winner) {
    const winMessage = document.getElementById('winMessage');
    const finalStats = document.getElementById('finalStats');
    
    // Set win message with appropriate styling
    if (winner === 'town') {
        winMessage.innerHTML = '🎉 Town Wins! 🎉<br><span style="font-size: 0.6em; color: #27ae60;">All Mafia members have been eliminated</span>';
        document.getElementById('winnerDisplay').style.background = 'linear-gradient(135deg, rgba(39, 174, 96, 0.4), rgba(30, 132, 73, 0.4))';
        document.getElementById('winnerDisplay').style.borderColor = '#27ae60';
        document.getElementById('winnerDisplay').style.boxShadow = '0 15px 50px rgba(39, 174, 96, 0.6)';
    } else {
        winMessage.innerHTML = '🩸 Mafia Wins! 🩸<br><span style="font-size: 0.6em; color: #e74c3c;">Mafia now equal or outnumber town</span>';
        document.getElementById('winnerDisplay').style.background = 'linear-gradient(135deg, rgba(231, 76, 60, 0.4), rgba(192, 57, 43, 0.4))';
        document.getElementById('winnerDisplay').style.borderColor = '#e74c3c';
        document.getElementById('winnerDisplay').style.boxShadow = '0 15px 50px rgba(231, 76, 60, 0.6)';
    }
    
    // Calculate final statistics
    const totalPlayers = gameState.players.length;
    const alivePlayers = gameState.players.filter(p => !gameState.eliminated.includes(p));
    const totalEliminated = gameState.eliminated.length;
    
    const eliminatedRoles = {};
    gameState.eliminated.forEach(player => {
        const role = gameState.assignments[player];
        if (!eliminatedRoles[role]) eliminatedRoles[role] = 0;
        eliminatedRoles[role]++;
    });
    
    const survivingRoles = {};
    alivePlayers.forEach(player => {
        const role = gameState.assignments[player];
        if (!survivingRoles[role]) survivingRoles[role] = 0;
        survivingRoles[role]++;
    });
    
    const eliminatedMafia = (eliminatedRoles['Godfather - Mafia'] || 0) + 
                            (eliminatedRoles['Executioner - Mafia'] || 0) + 
                            (eliminatedRoles['Regular Mafia'] || 0);
    const eliminatedNonMafia = totalEliminated - eliminatedMafia;
    
    // Build statistics display
    let statsHTML = `
        <strong>Game Duration:</strong> ${gameState.dayNumber - 1} Days / ${gameState.nightNumber - 1} Nights<br><br>
        <strong>Total Players:</strong> ${totalPlayers}<br>
        <strong>Survivors:</strong> ${alivePlayers.length}<br>
        <strong>Eliminated:</strong> ${totalEliminated}<br><br>
        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin-top: 20px;">
            <div style="background: rgba(39, 174, 96, 0.2); border: 2px solid #27ae60; border-radius: 12px; padding: 15px;">
                <strong style="color: #27ae60;">Survivors (${alivePlayers.length})</strong><br>
    `;
    
    alivePlayers.forEach(player => {
        statsHTML += `<span style="font-size: 0.9em;">${player} - ${gameState.assignments[player]}</span><br>`;
    });
    
    statsHTML += `
            </div>
            <div style="background: rgba(231, 76, 60, 0.2); border: 2px solid #e74c3c; border-radius: 12px; padding: 15px;">
                <strong style="color: #e74c3c;">Eliminated (${totalEliminated})</strong><br>
    `;
    
    gameState.eliminated.forEach(player => {
        statsHTML += `<span style="font-size: 0.9em;">${player} - ${gameState.assignments[player]}</span><br>`;
    });
    
    statsHTML += `
            </div>
        </div>
    `;
    
    finalStats.innerHTML = statsHTML;
    
    // Navigate to game over page
    goToPage(10);
}


function startOver() {
    // Confirm before resetting
    if (confirm('Are you sure you want to start a new game? All current progress will be lost.')) {
        // Reset all game state
        gameState.players = [];
        gameState.assignments = {};
        gameState.eliminated = [];
        gameState.playersWhoUsedSpecialAbility = [];
        gameState.currentPage = 1;
        gameState.dayNumber = 1;
        gameState.nightNumber = 1;
        gameState.jailerUsesLeft = 2;
        gameState.doctorSelfSaveUsed = false;
        gameState.shooterUsesLeft = 2;
        gameState.shooterShieldActive = true;
        gameState.godfatherShieldActive = true;
        gameState.godfatherAttackCount = 0;
        gameState.masterOfDisguiseSelection = null;
        gameState.masterOfDisguiseTransformed = false;
        gameState.eliminationCountRevealsLeft = 2;
        gameState.devoteeUsesLeft = 2;
        gameState.psychiatristUsesLeft = 2;
        gameState.eliminationCountRevealed = false;
        gameState.lockedPlayer = null;
        gameState.lockAbilityUsed = false;
        gameState.additionalEliminationUsed = false;
        gameState.roleSwapUsed = false;
        gameState.jailedPlayers = {};
        gameState.selectedForElimination = null;
        gameState.modTransformation = null;
        gameState.previousPage = 1;
        gameState.savedThisNight = [];
        gameState.nightSelections = {};
        gameState.selectedBullet = null;
        gameState.nightHistory = [];
        gameState.silencedPlayers = [];
        gameState.trialPlayer = null;
        gameState.mutePlayerUsed = false;
        gameState.trialUsed = false;
        gameState.guessRoleUsed = false;
        gameState.revealRoleUsed = false;
        
       // Clear bullet squares DOM elements
        const bullet1Square = document.getElementById('bullet1Square');
        const bullet2Square = document.getElementById('bullet2Square');
        
        if (bullet1Square) {
            const playerInSquare1 = bullet1Square.querySelector('.player-in-square');
            if (playerInSquare1) {
                playerInSquare1.remove();
            }
            bullet1Square.classList.remove('has-player', 'elimination-target');
            const dropZone1 = bullet1Square.querySelector('.drop-zone');
            if (dropZone1) {
                dropZone1.style.display = 'block';
            }
        }
        
        if (bullet2Square) {
            const playerInSquare2 = bullet2Square.querySelector('.player-in-square');
            if (playerInSquare2) {
                playerInSquare2.remove();
            }
            bullet2Square.classList.remove('has-player', 'elimination-target');
            const dropZone2 = bullet2Square.querySelector('.drop-zone');
            if (dropZone2) {
                dropZone2.style.display = 'block';
            }
        }
        
        // Reset bullet square wrapper labels to default color
        const bullet1Wrapper = bullet1Square ? bullet1Square.closest('.bullet-square-wrapper') : null;
        const bullet2Wrapper = bullet2Square ? bullet2Square.closest('.bullet-square-wrapper') : null;
        
        if (bullet1Wrapper) {
            const label1 = bullet1Wrapper.querySelector('.bullet-label-top');
            if (label1) {
                label1.style.color = '#3498db';
            }
        }
        
        if (bullet2Wrapper) {
            const label2 = bullet2Wrapper.querySelector('.bullet-label-top');
            if (label2) {
                label2.style.color = '#3498db';
            }
        }
        
        // Clear bullet result display
        const bulletResult = document.getElementById('bulletResult');
        if (bulletResult) {
            bulletResult.innerHTML = '';
        }
        
        // Reset bullet button selections
        const bullet1Button = document.getElementById('bullet1Button');
        const bullet2Button = document.getElementById('bullet2Button');
        if (bullet1Button) bullet1Button.classList.remove('selected');
        if (bullet2Button) bullet2Button.classList.remove('selected');
    
        // Reset UI elements
        document.getElementById('gameStatsHeader').style.display = 'none';
        
        // Go back to page 1 and reinitialize
        goToPage(1);
        initializeRoleSelection();
    }
}




// Show voting button starting from Day 2
function updateVotingButtonVisibility() {
    const votingBtn = document.getElementById('votingBtn');
    if (votingBtn && gameState.dayNumber >= 2) {
        votingBtn.style.display = 'inline-block';
    }
}

function showVotingPage() {
    setupVotingInterface();
    goToPage(11);
}

function setupVotingInterface() {
    const container = document.getElementById('votingPlayersList');
    container.innerHTML = '';
    
    const alivePlayers = gameState.players.filter(p => !gameState.eliminated.includes(p));
    
    alivePlayers.forEach(player => {
        const card = document.createElement('div');
        card.className = 'voting-player-card';
        card.id = `voting-card-${player}`;
        
        const role = gameState.assignments[player] || 'Unknown';
        const farsiRole = farsiTranslations.roles[role] || '';
        
        card.innerHTML = `
            <div class="voting-player-info">
                <input type="checkbox" class="voting-checkbox" id="trial-${player}" 
                       onchange="toggleTrial('${player}')">
                <label for="trial-${player}" class="voting-player-name">
                    ${player}
                    <span class="trial-indicator" id="trial-indicator-${player}" style="display: none;">⚖️ ON TRIAL</span>
                </label>
                <span style="color: #95a5a6; font-size: 0.9em;">${role}${farsiRole ? ` (${farsiRole})` : ''}</span>
            </div>
            <div class="vote-canvas-container">
                <canvas class="vote-canvas" id="canvas-${player}" width="150" height="80"></canvas>
                <button class="clear-canvas-btn" onclick="clearCanvas('${player}')" title="Clear">×</button>
            </div>
        `;
        
        container.appendChild(card);
        
        // Initialize canvas drawing after a short delay to ensure DOM is ready
        setTimeout(() => initializeCanvas(player), 50);
    });
}

function toggleTrial(player) {
    const checkbox = document.getElementById(`trial-${player}`);
    const indicator = document.getElementById(`trial-indicator-${player}`);
    const card = document.getElementById(`voting-card-${player}`);
    
    if (checkbox.checked) {
        indicator.style.display = 'inline';
        card.classList.add('on-trial');
    } else {
        indicator.style.display = 'none';
        card.classList.remove('on-trial');
    }
}

function initializeCanvas(player) {
    const canvas = document.getElementById(`canvas-${player}`);
    if (!canvas) return;
    
    const ctx = canvas.getContext('2d');
    let isDrawing = false;
    let lastX = 0;
    let lastY = 0;
    
    // Set drawing style
    ctx.strokeStyle = '#2c3e50';
    ctx.lineWidth = 3;
    ctx.lineCap = 'round';
    ctx.lineJoin = 'round';
    
    function startDrawing(e) {
        isDrawing = true;
        const rect = canvas.getBoundingClientRect();
        const x = (e.clientX || e.touches[0].clientX) - rect.left;
        const y = (e.clientY || e.touches[0].clientY) - rect.top;
        lastX = x;
        lastY = y;
    }
    
    function draw(e) {
        if (!isDrawing) return;
        e.preventDefault();
        
        const rect = canvas.getBoundingClientRect();
        const x = (e.clientX || e.touches[0].clientX) - rect.left;
        const y = (e.clientY || e.touches[0].clientY) - rect.top;
        
        ctx.beginPath();
        ctx.moveTo(lastX, lastY);
        ctx.lineTo(x, y);
        ctx.stroke();
        
        lastX = x;
        lastY = y;
    }
    
    function stopDrawing() {
        isDrawing = false;
    }
    
    // Mouse events
    canvas.addEventListener('mousedown', startDrawing);
    canvas.addEventListener('mousemove', draw);
    canvas.addEventListener('mouseup', stopDrawing);
    canvas.addEventListener('mouseout', stopDrawing);
    
    // Touch events
    canvas.addEventListener('touchstart', startDrawing);
    canvas.addEventListener('touchmove', draw);
    canvas.addEventListener('touchend', stopDrawing);
}

function clearCanvas(player) {
    const canvas = document.getElementById(`canvas-${player}`);
    if (canvas) {
        const ctx = canvas.getContext('2d');
        ctx.clearRect(0, 0, canvas.width, canvas.height);
    }
}


    </script>
</body>
</html>

